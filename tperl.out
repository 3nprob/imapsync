entering CODE(0x824fe40)
 390:	use strict;
 390:	use strict;
 390:	use strict;
 entering strict::import
  28:	    shift;
  29:	    $^H |= @_ ? bits(@_) : $default_bits;
entering CODE(0x824fe34)
 391:	use Getopt::Long;
 entering CODE(0x8227544)
  33:	use 5.004;
  33:	use 5.004;
  33:	use 5.004;
 entering CODE(0x8227538)
  35:	use strict;
  35:	use strict;
  35:	use strict;
  entering strict::import
   28:	    shift;
   29:	    $^H |= @_ ? bits(@_) : $default_bits;
 entering CODE(0x82274cc)
  37:	use vars qw($VERSION);
  entering CODE(0x8226eb4)
   3:	use 5.006;
   3:	use 5.006;
   3:	use 5.006;
  entering CODE(0x8218da8)
   7:	use warnings::register;
   Package /usr/share/perl/5.8/warnings/register.pm.
   3:	our $VERSION = '1.01';
   5:	require warnings;
   32:	1;
   7:	use warnings::register;
   7:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x821baa8)
   8:	use strict qw(vars subs);
   8:	use strict qw(vars subs);
   8:	use strict qw(vars subs);
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
    entering strict::bits
     12:	    my $bits = 0;
     13:	    my @wrong;
     14:	    foreach my $s (@_) {
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     18:	    if (@wrong) {
     22:	    $bits;
  Package /usr/share/perl/5.8/vars.pm.
  5:	our $VERSION = '1.01';
  46:	1;
  47:	__END__
  37:	use vars qw($VERSION);
  37:	use vars qw($VERSION);
  entering vars::import
   11:	    my $callpack = caller;
   12:	    my ($pack, @imports) = @_;
   13:	    my ($sym, $ch);
   14:	    foreach (@imports) {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
 entering CODE(0x8227544)
  43:	use Exporter;
  43:	use Exporter;
  43:	use Exporter;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x8227418)
  44:	use vars qw(@ISA @EXPORT @EXPORT_OK);
  44:	use vars qw(@ISA @EXPORT @EXPORT_OK);
  44:	use vars qw(@ISA @EXPORT @EXPORT_OK);
  entering vars::import
   11:	    my $callpack = caller;
   12:	    my ($pack, @imports) = @_;
   13:	    my ($sym, $ch);
   14:	    foreach (@imports) {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
 entering CODE(0x82272bc)
  55:	    @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
  56:	    @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure);
 entering CODE(0x821bb50)
  60:	use vars @EXPORT, @EXPORT_OK;
  60:	use vars @EXPORT, @EXPORT_OK;
  60:	use vars @EXPORT, @EXPORT_OK;
  entering vars::import
   11:	    my $callpack = caller;
   12:	    my ($pack, @imports) = @_;
   13:	    my ($sym, $ch);
   14:	    foreach (@imports) {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
 entering CODE(0x8321ccc)
  61:	use vars qw($error $debug $major_version $minor_version);
  61:	use vars qw($error $debug $major_version $minor_version);
  61:	use vars qw($error $debug $major_version $minor_version);
  entering vars::import
   11:	    my $callpack = caller;
   12:	    my ($pack, @imports) = @_;
   13:	    my ($sym, $ch);
   14:	    foreach (@imports) {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
 entering CODE(0x8321d08)
  64:		    $passthrough);
  64:		    $passthrough);
  63:	use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  entering vars::import
   11:	    my $callpack = caller;
   12:	    my ($pack, @imports) = @_;
   13:	    my ($sym, $ch);
   14:	    foreach (@imports) {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
 entering CODE(0x8321ed0)
  66:	use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  66:	use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  66:	use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  entering vars::import
   11:	    my $callpack = caller;
   12:	    my ($pack, @imports) = @_;
   13:	    my ($sym, $ch);
   14:	    foreach (@imports) {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
   15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
   16:		    if ($sym =~ /\W/) {
   28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
   29:		    *$sym =
   30:			(  $ch eq "\$" ? \$$sym
   31:			 : $ch eq "\@" ? \@$sym
   32:			 : $ch eq "\%" ? \%$sym
   33:			 : $ch eq "\*" ? \*$sym
   34:			 : $ch eq "\&" ? \&$sym 
   35:			 : do {
 entering CODE(0x8323010)
  223:	use constant CTL_TYPE    => 0;
  entering CODE(0x83231b4)
   3:	use strict;
   3:	use strict;
   3:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x83231c0)
   4:	use 5.006_00;
   4:	use 5.006_00;
   4:	use 5.006_00;
  entering CODE(0x83231cc)
   5:	use warnings::register;
   5:	use warnings::register;
   5:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x816fdf4)
   94:		    no strict 'refs';
   94:		    no strict 'refs';
   94:		    no strict 'refs';
   entering strict::unimport
    33:	    shift;
    34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
    entering strict::bits
     12:	    my $bits = 0;
     13:	    my @wrong;
     14:	    foreach my $s (@_) {
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     18:	    if (@wrong) {
     22:	    $bits;
  Package /usr/share/perl/5.8/constant.pm.
  7:	our($VERSION, %declared);
  8:	$VERSION = '1.05';
  13:	my %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };
  15:	my %forced_into_main = map +($_, 1),
  16:	    qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };
  18:	my %forbidden = (%keywords, %forced_into_main);
  115:	1;
  223:	use constant CTL_TYPE    => 0;
  223:	use constant CTL_TYPE    => 0;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8323064)
  233:	use constant CTL_CNAME   => 1;
  233:	use constant CTL_CNAME   => 1;
  233:	use constant CTL_CNAME   => 1;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8321d14)
  235:	use constant CTL_DEFAULT => 2;
  235:	use constant CTL_DEFAULT => 2;
  235:	use constant CTL_DEFAULT => 2;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x816f470)
  237:	use constant CTL_DEST    => 3;
  237:	use constant CTL_DEST    => 3;
  237:	use constant CTL_DEST    => 3;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x816f4f4)
  238:	 use constant   CTL_DEST_SCALAR => 0;
  238:	 use constant   CTL_DEST_SCALAR => 0;
  238:	 use constant   CTL_DEST_SCALAR => 0;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8323094)
  239:	 use constant   CTL_DEST_ARRAY  => 1;
  239:	 use constant   CTL_DEST_ARRAY  => 1;
  239:	 use constant   CTL_DEST_ARRAY  => 1;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x816fecc)
  240:	 use constant   CTL_DEST_HASH   => 2;
  240:	 use constant   CTL_DEST_HASH   => 2;
  240:	 use constant   CTL_DEST_HASH   => 2;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x816f440)
  241:	 use constant   CTL_DEST_CODE   => 3;
  241:	 use constant   CTL_DEST_CODE   => 3;
  241:	 use constant   CTL_DEST_CODE   => 3;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x83dd6cc)
  243:	use constant CTL_AMIN    => 4;
  243:	use constant CTL_AMIN    => 4;
  243:	use constant CTL_AMIN    => 4;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x83dd720)
  244:	use constant CTL_AMAX    => 5;
  244:	use constant CTL_AMAX    => 5;
  244:	use constant CTL_AMAX    => 5;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 Package /usr/share/perl/5.8/Getopt/Long.pm.
 38:	$VERSION        =  2.35;
 45:	@ISA = qw(Exporter);
 83:	my $requested_version = 0;
 136:	($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
 138:	($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
 140:	ConfigDefaults();
 entering Getopt::Long::ConfigDefaults
  89:	    if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  97:		$genprefix = "(--|-|\\+)";
  98:		$autoabbrev = 1;		# automatic abbrev of options
  99:		$bundling = 0;			# bundling off by default
  100:		$getopt_compat = 1;		# allow '+' to start options
  101:		$order = $PERMUTE;
  104:	    $debug = 0;			# for debugging
  105:	    $error = 0;			# error tally
  106:	    $ignorecase = 1;		# ignore case when matching options
  107:	    $passthrough = 0;		# leave unrecognized options alone
  108:	    $gnu_compat = 0;		# require --opt=val if value is optional
  109:	    $longprefix = "(--)";       # what does a long prefix look like
 148:	my $default_config = do {
 149:	    Getopt::Long::Configure ()
 entering Getopt::Long::Configure
  1208:	    my (@options) = @_;
  1210:	    my $prevconfig =
  1211:	      [ $error, $debug, $major_version, $minor_version,
  1212:		$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  1213:		$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  1214:		$longprefix ];
  1216:	    if ( ref($options[0]) eq 'ARRAY' ) {
  1223:	    my $opt;
  1224:	    foreach $opt ( @options ) {
  1313:	    $prevconfig;
 1414:	1;
 391:	use Getopt::Long;
 391:	use Getopt::Long;
 entering Getopt::Long::import
  114:	    my $pkg = shift;		# package
  115:	    my @syms = ();		# symbols to import
  116:	    my @config = ();		# configuration
  117:	    my $dest = \@syms;		# symbols first
  118:	    for ( @_ ) {
  126:	    local $Exporter::ExportLevel = 1;
  127:	    push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
  128:	    $pkg->SUPER::import(@syms);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   entering Exporter::export
    26:	  goto &{as_heavy()};
    26:	  goto &{as_heavy()};
    entering Exporter::as_heavy
     17:	  require Exporter::Heavy;
     entering CODE(0x84419dc)
      3:	use strict;
      3:	use strict;
      3:	use strict;
      entering strict::import
       28:	    shift;
       29:	    $^H |= @_ ? bits(@_) : $default_bits;
     entering CODE(0x84419e8)
      4:	no strict 'refs';
      4:	no strict 'refs';
      4:	no strict 'refs';
      entering strict::unimport
       33:	    shift;
       34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
       entering strict::bits
        12:	    my $bits = 0;
        13:	    my @wrong;
        14:	    foreach my $s (@_) {
        15:		push @wrong, $s unless exists $bitmask{$s};
        16:	        $bits |= $bitmask{$s} || 0;
        18:	    if (@wrong) {
        22:	    $bits;
     Package /usr/share/perl/5.8/Exporter/Heavy.pm.
     7:	require Exporter;  our $VERSION = $Exporter::VERSION;
     7:	require Exporter;  our $VERSION = $Exporter::VERSION;
     8:	$Carp::Internal{"Exporter::Heavy"} = 1;
     234:	1;
     20:	  my $c = (caller(1))[3];
     21:	  $c =~ s/.*:://;
     22:	  \&{"Exporter::Heavy::heavy_$c"};
     22:	  \&{"Exporter::Heavy::heavy_$c"};
    39:	    };
    40:	    local $SIG{__DIE__} = sub {
    45:	    };
    47:	    my($pkg, $callpkg, @imports) = @_;
    48:	    my($type, $sym, $cache_is_current, $oops);
    49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
    50:	                                   $Exporter::Cache{$pkg} ||= {});
    49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
    50:	                                   $Exporter::Cache{$pkg} ||= {});
    52:	    if (@imports) {
    145:		@imports = @$exports;
    148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
    149:	                              $Exporter::FailCache{$pkg} ||= {});
    148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
    149:	                              $Exporter::FailCache{$pkg} ||= {});
    151:	    if (@$fail) {
    176:	    warn "Importing into $callpkg from $pkg: ",
    177:			join(", ",sort @imports) if $Exporter::Verbose;
    179:	    foreach $sym (@imports) {
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    184:		*{"${callpkg}::$sym"} =
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    185:		    $type eq '&' ? \&{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    185:		    $type eq '&' ? \&{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    185:		    $type eq '&' ? \&{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
  130:	    Configure(@config) if @config;
entering CODE(0x824fe28)
 392:	use Mail::IMAPClient;
 entering CODE(0x8321e10)
  1:	use warnings;
  1:	use warnings;
  1:	use warnings;
  entering warnings::import
   213:	    shift;
   215:	    my $catmask ;
   216:	    my $fatal = 0 ;
   217:	    my $no_fatal = 0 ;
   219:	    my $mask = ${^WARNING_BITS} ;
   221:	    if (vec($mask, $Offsets{'all'}, 1)) {
   222:	        $mask |= $Bits{'all'} ;
   223:	        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
   226:	    push @_, 'all' unless @_;
   228:	    foreach my $word ( @_ ) {
   229:		if ($word eq 'FATAL') {
   238:		    $mask |= $catmask ;
   239:		    $mask |= $DeadBits{$word} if $fatal ;
   240:		    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;
   246:	    ${^WARNING_BITS} = $mask ;
 entering CODE(0x8321cc0)
  2:	use strict;
  2:	use strict;
  2:	use strict;
  entering strict::import
   28:	    shift;
   29:	    $^H |= @_ ? bits(@_) : $default_bits;
 entering CODE(0x84419ac)
  7:	use Mail::IMAPClient::MessageSet;
  entering CODE(0x8461428)
   1:	use warnings;
   1:	use warnings;
   1:	use warnings;
   entering warnings::import
    213:	    shift;
    215:	    my $catmask ;
    216:	    my $fatal = 0 ;
    217:	    my $no_fatal = 0 ;
    219:	    my $mask = ${^WARNING_BITS} ;
    221:	    if (vec($mask, $Offsets{'all'}, 1)) {
    222:	        $mask |= $Bits{'all'} ;
    223:	        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
    226:	    push @_, 'all' unless @_;
    228:	    foreach my $word ( @_ ) {
    229:		if ($word eq 'FATAL') {
    238:		    $mask |= $catmask ;
    239:		    $mask |= $DeadBits{$word} if $fatal ;
    240:		    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;
    246:	    ${^WARNING_BITS} = $mask ;
  entering CODE(0x8461434)
   2:	use strict;
   2:	use strict;
   2:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x8461518)
   18:	  , fallback => 1;
   entering CODE(0x8474304)
    131:	use warnings::register;
    131:	use warnings::register;
    131:	use warnings::register;
    entering warnings::register::import
     18:	    shift;
     19:	    my $package = (caller(0))[0];
     20:	    if (! defined $warnings::Bits{$package}) {
     21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
     entering warnings::register::mkMask
      9:	    my ($bit) = @_;
      10:	    my $mask = "";
      12:	    vec($mask, $bit, 1) = 1;
      13:	    return $mask;
     22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
     23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
     24:		foreach my $k (keys %warnings::Bits) {
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
     entering warnings::register::mkMask
      9:	    my ($bit) = @_;
      10:	    my $mask = "";
      12:	    vec($mask, $bit, 1) = 1;
      13:	    return $mask;
     28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
   Package /usr/share/perl/5.8/overload.pm.
   3:	our $VERSION = '1.04';
   5:	$overload::hint_bits = 0x20000; # HINT_LOCALIZE_HH
   96:	*StrVal = *AddrRef;
   109:	%constants = (
   110:		      'integer'	  =>  0x1000, # HINT_NEW_INTEGER
   111:		      'float'	  =>  0x2000, # HINT_NEW_FLOAT
   112:		      'binary'	  =>  0x4000, # HINT_NEW_BINARY
   113:		      'q'	  =>  0x8000, # HINT_NEW_STRING
   114:		      'qr'	  => 0x10000, # HINT_NEW_RE
   115:		     );
   117:	%ops = ( with_assign	  => "+ - * / % ** << >> x .",
   118:		 assign		  => "+= -= *= /= %= **= <<= >>= x= .=",
   119:		 num_comparison	  => "< <= >  >= == !=",
   120:		 '3way_comparison'=> "<=> cmp",
   121:		 str_comparison	  => "lt le gt ge eq ne",
   122:		 binary		  => "& | ^",
   123:		 unary		  => "neg ! ~",
   124:		 mutators	  => '++ --',
   125:		 func		  => "atan2 cos sin exp abs log sqrt int",
   126:		 conversion	  => 'bool "" 0+',
   127:		 iterators	  => '<>',
   128:		 dereferencing	  => '${} @{} %{} &{} *{}',
   129:		 special	  => 'nomethod fallback =');
   167:	1;
   18:	  , fallback => 1;
   17:	  , '@{}'    => "unfold"
   entering overload::import
    32:	  $package = (caller())[0];
    34:	  shift;
    35:	  $package->overload::OVERLOAD(@_);
    entering overload::OVERLOAD
     10:	  $package = shift;
     11:	  my %arg = @_;
     12:	  my ($sub, $fb);
     13:	  $ {$package . "::OVERLOAD"}{dummy}++; # Register with magic by touching.
     13:	  $ {$package . "::OVERLOAD"}{dummy}++; # Register with magic by touching.
     14:	  *{$package . "::()"} = \&nil; # Make it findable via fetchmethod.
     14:	  *{$package . "::()"} = \&nil; # Make it findable via fetchmethod.
     15:	  for (keys %arg) {
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     21:		$ {$package . "::(" . $_} = $sub;
     21:		$ {$package . "::(" . $_} = $sub;
     22:		$sub = \&nil;
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     21:		$ {$package . "::(" . $_} = $sub;
     21:		$ {$package . "::(" . $_} = $sub;
     22:		$sub = \&nil;
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     17:	      $fb = $arg{$_};
     28:	  ${$package . "::()"} = $fb; # Make it findable too (fallback only).
     28:	  ${$package . "::()"} = $fb; # Make it findable too (fallback only).
  Package Mail-IMAPClient-2.99_07/lib/Mail/IMAPClient/MessageSet.pm.
  279:	1;
  7:	use Mail::IMAPClient::MessageSet;
  7:	use Mail::IMAPClient::MessageSet;
 entering CODE(0x84612d8)
  9:	use Carp;  # to be removed
  9:	use Carp;  # to be removed
  9:	use Carp;  # to be removed
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x84612cc)
  10:	use Data::Dumper;  # to be removed
  entering CODE(0x846b660)
   16:	use 5.006_001;
   16:	use 5.006_001;
   16:	use 5.006_001;
  entering CODE(0x846b72c)
   20:	use Carp;
   20:	use Carp;
   20:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x846b6e4)
   23:	    @ISA = qw(Exporter);
   24:	    @EXPORT = qw(Dumper);
   25:	    @EXPORT_OK = qw(DumperX);
   30:	    eval {
   31:		require XSLoader;
   33:	    $Useperl = 1 if $@;
  entering CODE(0x84ca03c)
   641:	  my $bytes; { use bytes; $bytes = length }
   Package /usr/share/perl/5.8/bytes.pm.
   3:	our $VERSION = '1.02';
   5:	$bytes::hint_bits = 0x00000008;
   29:	1;
   30:	__END__
   641:	  my $bytes; { use bytes; $bytes = length }
   641:	  my $bytes; { use bytes; $bytes = length }
   entering bytes::import
    8:	    $^H |= $bytes::hint_bits;
  Package /usr/lib/perl/5.8/Data/Dumper.pm.
  12:	$VERSION = '2.121_08';
  17:	require Exporter;
  18:	require overload;
  36:	XSLoader::load( 'Data::Dumper' ) unless $Useperl;
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering Data::Dumper::bootstrap
  39:	$Indent     = 2         unless defined $Indent;
  40:	$Purity     = 0         unless defined $Purity;
  41:	$Pad        = ""        unless defined $Pad;
  42:	$Varname    = "VAR"     unless defined $Varname;
  43:	$Useqq      = 0         unless defined $Useqq;
  44:	$Terse      = 0         unless defined $Terse;
  45:	$Freezer    = ""        unless defined $Freezer;
  46:	$Toaster    = ""        unless defined $Toaster;
  47:	$Deepcopy   = 0         unless defined $Deepcopy;
  48:	$Quotekeys  = 1         unless defined $Quotekeys;
  49:	$Bless      = "bless"   unless defined $Bless;
  51:	$Maxdepth   = 0         unless defined $Maxdepth;
  52:	$Pair       = ' => '    unless defined $Pair;
  53:	$Useperl    = 0         unless defined $Useperl;
  54:	$Sortkeys   = 0         unless defined $Sortkeys;
  55:	$Deparse    = 0         unless defined $Deparse;
  627:	my %esc = (  
  628:	    "\a" => "\\a",
  629:	    "\b" => "\\b",
  630:	    "\t" => "\\t",
  631:	    "\n" => "\\n",
  632:	    "\f" => "\\f",
  633:	    "\r" => "\\r",
  634:	    "\e" => "\\e",
  635:	);
  680:	1;
  681:	__END__
  10:	use Data::Dumper;  # to be removed
  10:	use Data::Dumper;  # to be removed
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x8461308)
  12:	use Socket();
  entering CODE(0x84d2b54)
   6:	use Carp;
   6:	use Carp;
   6:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84d2b60)
   7:	use warnings::register;
   7:	use warnings::register;
   7:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x84d2cf8)
   10:	use XSLoader ();
   10:	use XSLoader ();
   10:	use XSLoader ();
  entering CODE(0x84d8a3c)
   180:	BEGIN {
  Package /usr/lib/perl/5.8/Socket.pm.
  3:	our($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
  4:	$VERSION = "1.78";
  9:	require Exporter;
  11:	@ISA = qw(Exporter);
  12:	@EXPORT = qw(
  13:		inet_aton inet_ntoa
  14:		sockaddr_family
  15:		pack_sockaddr_in unpack_sockaddr_in
  16:		pack_sockaddr_un unpack_sockaddr_un
  17:		sockaddr_in sockaddr_un
  18:		INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
  19:		AF_802
  20:		AF_AAL
  21:		AF_APPLETALK
  22:		AF_CCITT
  23:		AF_CHAOS
  24:		AF_CTF
  25:		AF_DATAKIT
  26:		AF_DECnet
  27:		AF_DLI
  28:		AF_ECMA
  29:		AF_GOSIP
  30:		AF_HYLINK
  31:		AF_IMPLINK
  32:		AF_INET
  33:		AF_INET6
  34:		AF_ISO
  35:		AF_KEY
  36:		AF_LAST
  37:		AF_LAT
  38:		AF_LINK
  39:		AF_MAX
  40:		AF_NBS
  41:		AF_NIT
  42:		AF_NS
  43:		AF_OSI
  44:		AF_OSINET
  45:		AF_PUP
  46:		AF_ROUTE
  47:		AF_SNA
  48:		AF_UNIX
  49:		AF_UNSPEC
  50:		AF_USER
  51:		AF_WAN
  52:		AF_X25
  53:		IOV_MAX
  54:		MSG_BCAST
  55:		MSG_BTAG
  56:		MSG_CTLFLAGS
  57:		MSG_CTLIGNORE
  58:		MSG_CTRUNC
  59:		MSG_DONTROUTE
  60:		MSG_DONTWAIT
  61:		MSG_EOF
  62:		MSG_EOR
  63:		MSG_ERRQUEUE
  64:		MSG_ETAG
  65:		MSG_FIN
  66:		MSG_MAXIOVLEN
  67:		MSG_MCAST
  68:		MSG_NOSIGNAL
  69:		MSG_OOB
  70:		MSG_PEEK
  71:		MSG_PROXY
  72:		MSG_RST
  73:		MSG_SYN
  74:		MSG_TRUNC
  75:		MSG_URG
  76:		MSG_WAITALL
  77:		MSG_WIRE
  78:		PF_802
  79:		PF_AAL
  80:		PF_APPLETALK
  81:		PF_CCITT
  82:		PF_CHAOS
  83:		PF_CTF
  84:		PF_DATAKIT
  85:		PF_DECnet
  86:		PF_DLI
  87:		PF_ECMA
  88:		PF_GOSIP
  89:		PF_HYLINK
  90:		PF_IMPLINK
  91:		PF_INET
  92:		PF_INET6
  93:		PF_ISO
  94:		PF_KEY
  95:		PF_LAST
  96:		PF_LAT
  97:		PF_LINK
  98:		PF_MAX
  99:		PF_NBS
  100:		PF_NIT
  101:		PF_NS
  102:		PF_OSI
  103:		PF_OSINET
  104:		PF_PUP
  105:		PF_ROUTE
  106:		PF_SNA
  107:		PF_UNIX
  108:		PF_UNSPEC
  109:		PF_USER
  110:		PF_WAN
  111:		PF_X25
  112:		SCM_CONNECT
  113:		SCM_CREDENTIALS
  114:		SCM_CREDS
  115:		SCM_RIGHTS
  116:		SCM_TIMESTAMP
  117:		SHUT_RD
  118:		SHUT_RDWR
  119:		SHUT_WR
  120:		SOCK_DGRAM
  121:		SOCK_RAW
  122:		SOCK_RDM
  123:		SOCK_SEQPACKET
  124:		SOCK_STREAM
  125:		SOL_SOCKET
  126:		SOMAXCONN
  127:		SO_ACCEPTCONN
  128:		SO_ATTACH_FILTER
  129:		SO_BACKLOG
  130:		SO_BROADCAST
  131:		SO_CHAMELEON
  132:		SO_DEBUG
  133:		SO_DETACH_FILTER
  134:		SO_DGRAM_ERRIND
  135:		SO_DONTLINGER
  136:		SO_DONTROUTE
  137:		SO_ERROR
  138:		SO_FAMILY
  139:		SO_KEEPALIVE
  140:		SO_LINGER
  141:		SO_OOBINLINE
  142:		SO_PASSCRED
  143:		SO_PASSIFNAME
  144:		SO_PEERCRED
  145:		SO_PROTOCOL
  146:		SO_PROTOTYPE
  147:		SO_RCVBUF
  148:		SO_RCVLOWAT
  149:		SO_RCVTIMEO
  150:		SO_REUSEADDR
  151:		SO_REUSEPORT
  152:		SO_SECURITY_AUTHENTICATION
  153:		SO_SECURITY_ENCRYPTION_NETWORK
  154:		SO_SECURITY_ENCRYPTION_TRANSPORT
  155:		SO_SNDBUF
  156:		SO_SNDLOWAT
  157:		SO_SNDTIMEO
  158:		SO_STATE
  159:		SO_TYPE
  160:		SO_USELOOPBACK
  161:		SO_XOPEN
  162:		SO_XSE
  163:		UIO_MAXIOV
  164:	);
  166:	@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF
  175:	%EXPORT_TAGS = (
  176:	    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],
  177:	    all     => [@EXPORT, @EXPORT_OK],
  178:	);
  186:	*CR   = \CR();
  187:	*LF   = \LF();
  188:	*CRLF = \CRLF();
  227:	XSLoader::load 'Socket', $VERSION;
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering Socket::bootstrap
  229:	1;
  12:	use Socket();
  12:	use Socket();
 entering CODE(0x846135c)
  13:	use IO::Socket();
  entering CODE(0x84d88b0)
   11:	use IO::Handle;
   11:	use IO::Handle;
   11:	use IO::Handle;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84665dc)
   12:	use Socket 1.3;
   12:	use Socket 1.3;
   entering UNIVERSAL::VERSION
   12:	use Socket 1.3;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x8466570)
   13:	use Carp;
   13:	use Carp;
   13:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84664b0)
   14:	use strict;
   14:	use strict;
   14:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x84dff80)
   16:	use Exporter;
   16:	use Exporter;
   16:	use Exporter;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84e0028)
   17:	use Errno;
   entering CODE(0x84e0388)
    7:	use Exporter ();
    7:	use Exporter ();
    7:	use Exporter ();
   entering CODE(0x84e0394)
    8:	use strict;
    8:	use strict;
    8:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x8516ce4)
    187:		no strict 'refs';
    187:		no strict 'refs';
    187:		no strict 'refs';
    entering strict::unimport
     33:	    shift;
     34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
     entering strict::bits
      12:	    my $bits = 0;
      13:	    my @wrong;
      14:	    foreach my $s (@_) {
      15:		push @wrong, $s unless exists $bitmask{$s};
      16:	        $bits |= $bitmask{$s} || 0;
      18:	    if (@wrong) {
      22:	    $bits;
   Package /usr/lib/perl/5.8/Errno.pm.
   6:	our (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);
   10:	$VERSION = "1.09_01";
   11:	$VERSION = eval $VERSION;
   1:	1.09_01
   12:	@ISA = qw(Exporter);
   14:	@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF
   15:		ENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT
   16:		ECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED
   17:		ECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ
   18:		ENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL
   19:		EINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS
   20:		EOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR
   21:		EBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL
   22:		EDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET
   23:		EUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK
   24:		ECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL
   25:		ENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM
   26:		EBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS
   27:		EHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE
   28:		ENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC
   29:		ENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV
   30:		ETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);
   32:	%EXPORT_TAGS = (
   33:	    POSIX => [qw(
   34:		E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY
   35:		EBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
   36:		EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH
   37:		EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
   38:		EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS
   39:		ENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK
   40:		ENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
   41:		EPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART
   42:		EROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT
   43:		ETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV
   44:	    )]
   45:	);
   199:	*CLEAR = \&STORE;
   200:	*DELETE = \&STORE;
   223:	tie %!, __PACKAGE__;
   entering Errno::TIEHASH
    180:	sub TIEHASH { bless [] }
   225:	1;
   226:	__END__
   17:	use Errno;
   17:	use Errno;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  Package /usr/lib/perl/5.8/IO/Socket.pm.
  9:	require 5.006;
  15:	our(@ISA, $VERSION, @EXPORT_OK);
  21:	require IO::Socket::INET;
  entering CODE(0x8528fcc)
   9:	use strict;
   9:	use strict;
   9:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x85371e8)
   11:	use IO::Socket;
   11:	use IO::Socket;
   11:	use IO::Socket;
   entering IO::Socket::import
    31:	    my $pkg = shift;
    32:	    if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
    35:		my $callpkg = caller;
    36:		Exporter::export 'Socket', $callpkg, @_;
    entering Exporter::export
     26:	  goto &{as_heavy()};
     26:	  goto &{as_heavy()};
     entering Exporter::as_heavy
      17:	  require Exporter::Heavy;
      20:	  my $c = (caller(1))[3];
      21:	  $c =~ s/.*:://;
      22:	  \&{"Exporter::Heavy::heavy_$c"};
      22:	  \&{"Exporter::Heavy::heavy_$c"};
     39:	    };
     40:	    local $SIG{__DIE__} = sub {
     45:	    };
     47:	    my($pkg, $callpkg, @imports) = @_;
     48:	    my($type, $sym, $cache_is_current, $oops);
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     52:	    if (@imports) {
     145:		@imports = @$exports;
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     151:	    if (@$fail) {
     176:	    warn "Importing into $callpkg from $pkg: ",
     177:			join(", ",sort @imports) if $Exporter::Verbose;
     179:	    foreach $sym (@imports) {
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
  entering CODE(0x8537200)
   12:	use Socket;
   12:	use Socket;
   12:	use Socket;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84e0418)
   13:	use Carp;
   13:	use Carp;
   13:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x853720c)
   14:	use Exporter;
   14:	use Exporter;
   14:	use Exporter;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x8537224)
   15:	use Errno;
   15:	use Errno;
   15:	use Errno;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  Package /usr/lib/perl/5.8/IO/Socket/INET.pm.
  10:	our(@ISA, $VERSION);
  17:	@ISA = qw(IO::Socket);
  18:	$VERSION = "1.29";
  20:	my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;
  22:	IO::Socket::INET->register_domain( AF_INET );
  entering Socket::AUTOLOAD for Socket::AF_INET
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering IO::Socket::register_domain
   55:	    my($p,$d) = @_;
   56:	    $domain2pkg[$d] = $p;
  24:	my %socket_type = ( tcp  => SOCK_STREAM,
  25:			    udp  => SOCK_DGRAM,
  26:			    icmp => SOCK_RAW
  27:			  );
  entering Socket::AUTOLOAD for Socket::SOCK_STREAM
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering Socket::AUTOLOAD for Socket::SOCK_DGRAM
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering Socket::AUTOLOAD for Socket::SOCK_RAW
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  275:	1;
  22:	require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
  entering CODE(0x854e8d8)
   9:	use strict;
   9:	use strict;
   9:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x854e9b0)
   11:	use IO::Socket;
   11:	use IO::Socket;
   11:	use IO::Socket;
   entering IO::Socket::import
    31:	    my $pkg = shift;
    32:	    if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
    35:		my $callpkg = caller;
    36:		Exporter::export 'Socket', $callpkg, @_;
    entering Exporter::export
     26:	  goto &{as_heavy()};
     26:	  goto &{as_heavy()};
     entering Exporter::as_heavy
      17:	  require Exporter::Heavy;
      20:	  my $c = (caller(1))[3];
      21:	  $c =~ s/.*:://;
      22:	  \&{"Exporter::Heavy::heavy_$c"};
      22:	  \&{"Exporter::Heavy::heavy_$c"};
     39:	    };
     40:	    local $SIG{__DIE__} = sub {
     45:	    };
     47:	    my($pkg, $callpkg, @imports) = @_;
     48:	    my($type, $sym, $cache_is_current, $oops);
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     52:	    if (@imports) {
     145:		@imports = @$exports;
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     151:	    if (@$fail) {
     176:	    warn "Importing into $callpkg from $pkg: ",
     177:			join(", ",sort @imports) if $Exporter::Verbose;
     179:	    foreach $sym (@imports) {
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
  entering CODE(0x854e9c8)
   12:	use Socket;
   12:	use Socket;
   12:	use Socket;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x8554658)
   13:	use Carp;
   13:	use Carp;
   13:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  Package /usr/lib/perl/5.8/IO/Socket/UNIX.pm.
  10:	our(@ISA, $VERSION);
  15:	@ISA = qw(IO::Socket);
  16:	$VERSION = "1.22";
  17:	$VERSION = eval $VERSION;
  1:	1.22
  19:	IO::Socket::UNIX->register_domain( AF_UNIX );
  entering Socket::AUTOLOAD for Socket::AF_UNIX
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering IO::Socket::register_domain
   55:	    my($p,$d) = @_;
   56:	    $domain2pkg[$d] = $p;
  66:	1; # Keep require happy
  24:	@ISA = qw(IO::Handle);
  26:	$VERSION = "1.29";
  28:	@EXPORT_OK = qw(sockatmark);
  52:	my @domain2pkg;
  250:	my $intsize = length(pack("i",0));
  302:	1;
  13:	use IO::Socket();
  13:	use IO::Socket();
 entering CODE(0x846b4f8)
  14:	use IO::Select();
  entering CODE(0x855fe80)
   9:	use     strict;
   9:	use     strict;
   9:	use     strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x855fe68)
   10:	use warnings::register;
   10:	use warnings::register;
   10:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x855fec8)
   11:	use     vars qw($VERSION @ISA);
   11:	use     vars qw($VERSION @ISA);
   11:	use     vars qw($VERSION @ISA);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/lib/perl/5.8/IO/Select.pm.
  12:	require Exporter;
  14:	$VERSION = "1.17";
  16:	@ISA = qw(Exporter); # This is only so we can do version checking
  231:	1;
  232:	__END__
  14:	use IO::Select();
  14:	use IO::Select();
 entering CODE(0x8461290)
  15:	use IO::File();
  entering CODE(0x8572e44)
   5:	use 5.006_001;
   5:	use 5.006_001;
   5:	use 5.006_001;
  entering CODE(0x85730fc)
   6:	use strict;
   6:	use strict;
   6:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x857e7e8)
   8:	use Carp;
   8:	use Carp;
   8:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x857e7f4)
   9:	use Symbol;
   9:	use Symbol;
   9:	use Symbol;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x857e800)
   10:	use SelectSaver;
   10:	use SelectSaver;
   10:	use SelectSaver;
  entering CODE(0x857e80c)
   11:	use IO::Seekable;
   entering CODE(0x857ea70)
    5:	use 5.006_001;
    5:	use 5.006_001;
    5:	use 5.006_001;
   entering CODE(0x857ea7c)
    6:	use Carp;
    6:	use Carp;
    6:	use Carp;
    entering Exporter::import
     30:	  my $pkg = shift;
     31:	  my $callpkg = caller($ExportLevel);
     33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     40:	  return export $pkg, $callpkg, @_
     41:	    if $Verbose or $Debug or @$fail > 1;
     42:	  my $export_cache = ($Cache{$pkg} ||= {});
     43:	  my $args = @_ or @_ = @$exports;
     45:	  local $_;
     46:	  if ($args and not %$export_cache) {
     50:	  my $heavy;
     53:	  if ($args or $fail) {
     54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
     55:	               or @$fail and $_ eq $fail->[0])) and last
     56:	                 foreach (@_);
     56:	                 foreach (@_);
     61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
     63:		sub {require Carp; &Carp::carp};
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   entering CODE(0x857ea88)
    7:	use strict;
    7:	use strict;
    7:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x857eb24)
    9:	use IO::Handle ();
    9:	use IO::Handle ();
    9:	use IO::Handle ();
   entering CODE(0x857eb18)
    12:	use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
    entering CODE(0x857efa4)
     6:	use XSLoader ();
     6:	use XSLoader ();
     6:	use XSLoader ();
    Package /usr/lib/perl/5.8/Fcntl.pm.
    3:	our($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);
    5:	require Exporter;
    7:	@ISA = qw(Exporter);
    8:	$VERSION = "1.05";
    11:	@EXPORT =
    12:	  qw(
    13:		FD_CLOEXEC
    14:		F_ALLOCSP
    15:		F_ALLOCSP64
    16:		F_COMPAT
    17:		F_DUP2FD
    18:		F_DUPFD
    19:		F_EXLCK
    20:		F_FREESP
    21:		F_FREESP64
    22:		F_FSYNC
    23:		F_FSYNC64
    24:		F_GETFD
    25:		F_GETFL
    26:		F_GETLK
    27:		F_GETLK64
    28:		F_GETOWN
    29:		F_NODNY
    30:		F_POSIX
    31:		F_RDACC
    32:		F_RDDNY
    33:		F_RDLCK
    34:		F_RWACC
    35:		F_RWDNY
    36:		F_SETFD
    37:		F_SETFL
    38:		F_SETLK
    39:		F_SETLK64
    40:		F_SETLKW
    41:		F_SETLKW64
    42:		F_SETOWN
    43:		F_SHARE
    44:		F_SHLCK
    45:		F_UNLCK
    46:		F_UNSHARE
    47:		F_WRACC
    48:		F_WRDNY
    49:		F_WRLCK
    50:		O_ACCMODE
    51:		O_ALIAS
    52:		O_APPEND
    53:		O_ASYNC
    54:		O_BINARY
    55:		O_CREAT
    56:		O_DEFER
    57:		O_DIRECT
    58:		O_DIRECTORY
    59:		O_DSYNC
    60:		O_EXCL
    61:		O_EXLOCK
    62:		O_LARGEFILE
    63:		O_NDELAY
    64:		O_NOCTTY
    65:		O_NOFOLLOW
    66:		O_NOINHERIT
    67:		O_NONBLOCK
    68:		O_RANDOM
    69:		O_RAW
    70:		O_RDONLY
    71:		O_RDWR
    72:		O_RSRC
    73:		O_RSYNC
    74:		O_SEQUENTIAL
    75:		O_SHLOCK
    76:		O_SYNC
    77:		O_TEMPORARY
    78:		O_TEXT
    79:		O_TRUNC
    80:		O_WRONLY
    81:	     );
    84:	@EXPORT_OK = qw(
    85:		DN_ACCESS
    86:		DN_ATTRIB
    87:		DN_CREATE
    88:		DN_DELETE
    89:		DN_MODIFY
    90:		DN_MULTISHOT
    91:		DN_RENAME
    92:		FAPPEND
    93:		FASYNC
    94:		FCREAT
    95:		FDEFER
    96:		FDSYNC
    97:		FEXCL
    98:		FLARGEFILE
    99:		FNDELAY
    100:		FNONBLOCK
    101:		FRSYNC
    102:		FSYNC
    103:		FTRUNC
    104:		F_GETLEASE
    105:		F_GETSIG
    106:		F_NOTIFY
    107:		F_SETLEASE
    108:		F_SETSIG
    109:		LOCK_EX
    110:		LOCK_MAND
    111:		LOCK_NB
    112:		LOCK_READ
    113:		LOCK_RW
    114:		LOCK_SH
    115:		LOCK_UN
    116:		LOCK_WRITE
    117:		O_IGNORE_CTTY
    118:		O_NOATIME
    119:		O_NOLINK
    120:		O_NOTRANS
    121:		SEEK_CUR
    122:		SEEK_END
    123:		SEEK_SET
    124:		S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT
    125:		S_IREAD S_IWRITE S_IEXEC
    126:		S_IRGRP S_IWGRP S_IXGRP S_IRWXG
    127:		S_IROTH S_IWOTH S_IXOTH S_IRWXO
    128:		S_IRUSR S_IWUSR S_IXUSR S_IRWXU
    129:		S_ISUID S_ISGID S_ISVTX S_ISTXT
    130:		_S_IFMT S_IFREG S_IFDIR S_IFLNK
    131:		&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO
    132:		&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE
    133:	);
    135:	%EXPORT_TAGS = (
    136:	    'flock'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],
    137:	    'Fcompat' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE
    138:			     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],
    139:	    'seek'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],
    140:	    'mode'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT
    141:			     _S_IFMT S_IFREG S_IFDIR S_IFLNK
    142:			     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT
    143:			     S_IRUSR S_IWUSR S_IXUSR S_IRWXU
    144:			     S_IRGRP S_IWGRP S_IXGRP S_IRWXG
    145:			     S_IROTH S_IWOTH S_IXOTH S_IRWXO
    146:			     S_IREAD S_IWRITE S_IEXEC
    147:			     S_ISREG S_ISDIR S_ISLNK S_ISSOCK
    148:			     S_ISBLK S_ISCHR S_ISFIFO
    149:			     S_ISWHT S_ISENFMT		
    150:			     S_IFMT S_IMODE
    151:	                  )],
    152:	);
    179:	XSLoader::load 'Fcntl', $VERSION;
    entering XSLoader::load
     25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
     27:	    my($module) = $_[0];
     30:	    my $b = "$module\::bootstrap";
     31:	    goto &$b if defined &$b;
     33:	    goto retry unless $module and defined &dl_load_file;
     35:	    my @modparts = split(/::/,$module);
     36:	    my $modfname = $modparts[-1];
     38:	    my $modpname = join('/',@modparts);
     39:	    my $modlibname = (caller())[1];
     40:	    my $c = @modparts;
     41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
     42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
     46:	    my $bs = $file;
     47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
     49:	    goto retry if not -f $file or -s $bs;
     51:	    my $bootname = "boot_$module";
     52:	    $bootname =~ s/\W/_/g;
     53:	    @DynaLoader::dl_require_symbols = ($bootname);
     55:	    my $boot_symbol_ref;
     57:	    if ($^O eq 'darwin') {
     70:	    my $libref = dl_load_file($file, 0) or do { 
     entering DynaLoader::dl_load_file
     74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
     76:	    my @unresolved = dl_undef_symbols();
     entering DynaLoader::dl_undef_symbols
     77:	    if (@unresolved) {
     82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
     entering DynaLoader::dl_find_symbol
     87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
     89:	  boot:
     90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
     entering DynaLoader::dl_install_xsub
     93:	    return &$xs(@_);
     entering Fcntl::bootstrap
    181:	1;
    12:	use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
    12:	use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
    entering Exporter::import
     30:	  my $pkg = shift;
     31:	  my $callpkg = caller($ExportLevel);
     33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     40:	  return export $pkg, $callpkg, @_
     41:	    if $Verbose or $Debug or @$fail > 1;
     42:	  my $export_cache = ($Cache{$pkg} ||= {});
     43:	  my $args = @_ or @_ = @$exports;
     45:	  local $_;
     46:	  if ($args and not %$export_cache) {
     48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
     48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
     47:	    s/^&//, $export_cache->{$_} = 1
     50:	  my $heavy;
     53:	  if ($args or $fail) {
     54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
     55:	               or @$fail and $_ eq $fail->[0])) and last
     56:	                 foreach (@_);
     56:	                 foreach (@_);
     61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
     63:		sub {require Carp; &Carp::carp};
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   Package /usr/lib/perl/5.8/IO/Seekable.pm.
   8:	our($VERSION, @EXPORT, @ISA);
   13:	require Exporter;
   15:	@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
   16:	@ISA = qw(Exporter);
   18:	$VERSION = "1.10";
   19:	$VERSION = eval $VERSION;
   1:	1.10
   36:	1;
   11:	use IO::Seekable;
   11:	use IO::Seekable;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x857e848)
   12:	use File::Spec;
   entering CODE(0x858de0c)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x858de18)
    4:	use vars qw(@ISA $VERSION);
    4:	use vars qw(@ISA $VERSION);
    4:	use vars qw(@ISA $VERSION);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/share/perl/5.8/File/Spec.pm.
   6:	$VERSION = '3.12';
   7:	$VERSION = eval $VERSION;
   1:	3.12
   9:	my %module = (MacOS   => 'Mac',
   10:		      MSWin32 => 'Win32',
   11:		      os2     => 'OS2',
   12:		      VMS     => 'VMS',
   13:		      epoc    => 'Epoc',
   14:		      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
   15:		      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
   16:		      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
   17:		      cygwin  => 'Cygwin');
   19:	my $module = $module{$^O} || 'Unix';
   21:	require "File/Spec/$module.pm";
   entering CODE(0x859950c)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x8599518)
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   entering CODE(0x8599e00)
    61:		no strict 'refs';
    61:		no strict 'refs';
    61:		no strict 'refs';
    entering strict::unimport
     33:	    shift;
     34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
     entering strict::bits
      12:	    my $bits = 0;
      13:	    my @wrong;
      14:	    foreach my $s (@_) {
      15:		push @wrong, $s unless exists $bitmask{$s};
      16:	        $bits |= $bitmask{$s} || 0;
      18:	    if (@wrong) {
      22:	    $bits;
   Package /usr/share/perl/5.8/File/Spec/Unix.pm.
   6:	$VERSION = '1.5';
   55:	my $tmpdir;
   56:	sub _tmpdir {
   266:	1;
   22:	@ISA = ("File::Spec::$module");
   24:	1;
   12:	use File::Spec;
   12:	use File::Spec;
  Package /usr/lib/perl/5.8/IO/File.pm.
  7:	our($VERSION, @EXPORT, @EXPORT_OK, @ISA);
  14:	require Exporter;
  16:	@ISA = qw(IO::Handle IO::Seekable Exporter);
  18:	$VERSION = "1.13";
  20:	@EXPORT = @IO::Seekable::EXPORT;
  22:	eval {
  24:	    require Fcntl;
  25:	    my @O = grep /^O_/, @Fcntl::EXPORT;
  26:	    Fcntl->import(@O);  # first we import what we want to export
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  27:	    push(@EXPORT, @O);
  86:	1;
  15:	use IO::File();
  15:	use IO::File();
 entering CODE(0x84612fc)
  16:	use Carp qw(carp);
  16:	use Carp qw(carp);
  16:	use Carp qw(carp);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x8537140)
  18:	use Fcntl       qw(F_GETFL F_SETFL O_NONBLOCK);
  18:	use Fcntl       qw(F_GETFL F_SETFL O_NONBLOCK);
  18:	use Fcntl       qw(F_GETFL F_SETFL O_NONBLOCK);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x8599398)
  19:	use Errno       qw/EAGAIN/;
  19:	use Errno       qw/EAGAIN/;
  19:	use Errno       qw/EAGAIN/;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x85b0b48)
  20:	use List::Util  qw/first min max sum/;
  entering CODE(0x85baa60)
   9:	use strict;
   9:	use strict;
   9:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x85baa6c)
   10:	use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
   10:	use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
   10:	use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/lib/perl/5.8/List/Util.pm.
  11:	require Exporter;
  13:	@ISA        = qw(Exporter);
  14:	@EXPORT_OK  = qw(first min max minstr maxstr reduce sum shuffle);
  15:	$VERSION    = "1.18";
  16:	$XS_VERSION = $VERSION;
  17:	$VERSION    = eval $VERSION;
  1:	1.18
  19:	eval {
  22:	  local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  23:	  eval {
  27:	  } or do {
  24:	    require XSLoader;
  25:	    XSLoader::load('List::Util', $XS_VERSION);
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering List::Util::bootstrap
  26:	    1;
  37:	if (!defined &reduce) {
  75:	eval <<'ESQ' if !defined &sum;
  101:	1;
  20:	use List::Util  qw/first min max sum/;
  20:	use List::Util  qw/first min max sum/;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x85b113c)
  21:	use Digest::HMAC_MD5 qw/hmac_md5_hex/; 
  entering CODE(0x85c21ec)
   4:	use strict;
   4:	use strict;
   4:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x85c21f8)
   5:	use Digest::MD5  qw(md5);
   entering CODE(0x85c23e4)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x85c23f0)
    4:	use vars qw($VERSION @ISA @EXPORT_OK);
    4:	use vars qw($VERSION @ISA @EXPORT_OK);
    4:	use vars qw($VERSION @ISA @EXPORT_OK);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/lib/perl/5.8/Digest/MD5.pm.
   6:	$VERSION = '2.36';  # $Date: 2005/11/30 13:46:47 $
   8:	require Exporter;
   9:	*import = \&Exporter::import;
   10:	@EXPORT_OK = qw(md5 md5_hex md5_base64);
   12:	eval {
   13:	    require Digest::base;
   entering CODE(0x85c2a14)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x85c2a20)
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/share/perl/5.8/Digest/base.pm.
   5:	$VERSION = "1.00";
   67:	1;
   14:	    push(@ISA, 'Digest::base');
   16:	if ($@) {
   22:	eval {
   23:	    require XSLoader;
   24:	    XSLoader::load('Digest::MD5', $VERSION);
   entering XSLoader::load
    25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
    27:	    my($module) = $_[0];
    30:	    my $b = "$module\::bootstrap";
    31:	    goto &$b if defined &$b;
    33:	    goto retry unless $module and defined &dl_load_file;
    35:	    my @modparts = split(/::/,$module);
    36:	    my $modfname = $modparts[-1];
    38:	    my $modpname = join('/',@modparts);
    39:	    my $modlibname = (caller())[1];
    40:	    my $c = @modparts;
    41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
    42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
    46:	    my $bs = $file;
    47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
    49:	    goto retry if not -f $file or -s $bs;
    51:	    my $bootname = "boot_$module";
    52:	    $bootname =~ s/\W/_/g;
    53:	    @DynaLoader::dl_require_symbols = ($bootname);
    55:	    my $boot_symbol_ref;
    57:	    if ($^O eq 'darwin') {
    70:	    my $libref = dl_load_file($file, 0) or do { 
    entering DynaLoader::dl_load_file
    74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
    76:	    my @unresolved = dl_undef_symbols();
    entering DynaLoader::dl_undef_symbols
    77:	    if (@unresolved) {
    82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
    entering DynaLoader::dl_find_symbol
    87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
    89:	  boot:
    90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
    entering DynaLoader::dl_install_xsub
    93:	    return &$xs(@_);
    entering Digest::MD5::bootstrap
   26:	if ($@) {
   41:	    *reset = \&new;
   44:	1;
   45:	__END__
   5:	use Digest::MD5  qw(md5);
   5:	use Digest::MD5  qw(md5);
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    47:	    s/^&//, $export_cache->{$_} = 1
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x85c2204)
   6:	use Digest::HMAC qw(hmac);
   entering CODE(0x85c2540)
    4:	use strict;
    4:	use strict;
    4:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x83d4904)
    47:	use vars qw(@EXPORT_OK);
    47:	use vars qw(@EXPORT_OK);
    47:	use vars qw(@EXPORT_OK);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/share/perl5/Digest/HMAC.pm.
   2:	$VERSION = "1.01";
   45:	require Exporter;
   46:	*import = \&Exporter::import;
   48:	@EXPORT_OK = qw(hmac hmac_hex);
   64:	1;
   6:	use Digest::HMAC qw(hmac);
   6:	use Digest::HMAC qw(hmac);
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    47:	    s/^&//, $export_cache->{$_} = 1
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x85c2288)
   9:	use vars qw(@ISA);
   9:	use vars qw(@ISA);
   9:	use vars qw(@ISA);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  entering CODE(0x83d4d60)
   20:	use vars qw(@EXPORT_OK);
   20:	use vars qw(@EXPORT_OK);
   20:	use vars qw(@EXPORT_OK);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/share/perl5/Digest/HMAC_MD5.pm.
  2:	$VERSION="1.01";
  10:	@ISA=qw(Digest::HMAC);
  11:	sub new
  12:	{
  18:	require Exporter;
  19:	*import = \&Exporter::import;
  21:	@EXPORT_OK=qw(hmac_md5 hmac_md5_hex);
  33:	1;
  21:	use Digest::HMAC_MD5 qw/hmac_md5_hex/; 
  21:	use Digest::HMAC_MD5 qw/hmac_md5_hex/; 
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x85729e8)
  22:	use MIME::Base64;
  entering CODE(0x83d5060)
   5:	use strict;
   5:	use strict;
   5:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x83d506c)
   6:	use vars qw(@ISA @EXPORT $VERSION);
   6:	use vars qw(@ISA @EXPORT $VERSION);
   6:	use vars qw(@ISA @EXPORT $VERSION);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/lib/perl/5.8/MIME/Base64.pm.
  8:	require Exporter;
  9:	@ISA = qw(Exporter);
  10:	@EXPORT = qw(encode_base64 decode_base64);
  12:	$VERSION = '3.07';
  14:	require XSLoader;
  15:	XSLoader::load('MIME::Base64', $VERSION);
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering MIME::Base64::bootstrap
  17:	*encode = \&encode_base64;
  18:	*decode = \&decode_base64;
  20:	1;
  22:	use MIME::Base64;
  22:	use MIME::Base64;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x85ba298)
  24:	use constant Unconnected   => 0;
  24:	use constant Unconnected   => 0;
  24:	use constant Unconnected   => 0;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x85b1100)
  25:	use constant Connected     => 1; # connected; not logged in
  25:	use constant Connected     => 1; # connected; not logged in
  25:	use constant Connected     => 1; # connected; not logged in
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x85ba268)
  26:	use constant Authenticated => 2; # logged in; no mailbox selected
  26:	use constant Authenticated => 2; # logged in; no mailbox selected
  26:	use constant Authenticated => 2; # logged in; no mailbox selected
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x857e83c)
  27:	use constant Selected      => 3; # mailbox selected
  27:	use constant Selected      => 3; # mailbox selected
  27:	use constant Selected      => 3; # mailbox selected
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x83d50e4)
  29:	use constant INDEX         => 0; # Array index for output line number
  29:	use constant INDEX         => 0; # Array index for output line number
  29:	use constant INDEX         => 0; # Array index for output line number
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x83d5450)
  30:	use constant TYPE          => 1; # Array index for line type
  30:	use constant TYPE          => 1; # Array index for line type
  30:	use constant TYPE          => 1; # Array index for line type
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x85bab08)
  32:	use constant DATA          => 2; # Array index for output line data
  32:	use constant DATA          => 2; # Array index for output line data
  32:	use constant DATA          => 2; # Array index for output line data
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x83d5558)
  34:	use constant NonFolderArg => 1;  # Value to pass to Massage to
  34:	use constant NonFolderArg => 1;  # Value to pass to Massage to
  34:	use constant NonFolderArg => 1;  # Value to pass to Massage to
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x83d5bb8)
  63:	   { no strict 'refs';
  63:	   { no strict 'refs';
  63:	   { no strict 'refs';
  entering strict::unimport
   33:	    shift;
   34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
   entering strict::bits
    12:	    my $bits = 0;
    13:	    my @wrong;
    14:	    foreach my $s (@_) {
    15:		push @wrong, $s unless exists $bitmask{$s};
    16:	        $bits |= $bitmask{$s} || 0;
    18:	    if (@wrong) {
    22:	    $bits;
 entering CODE(0x83d59f0)
  58:	   foreach my $datum (
  59:	     qw(State Port Server Folder Peek User Password Timeout Buffer
  60:	        Debug Count Uid Debug_fh Maxtemperrors Authmechanism Authcallback
  61:	        Ranges Readmethod Showcredentials Prewritemethod Ignoresizeerrors
  62:	        Supportedflags Proxy))
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
  65:	     };
 Package Mail-IMAPClient-2.99_07/lib/Mail/IMAPClient.pm.
 5:	our $VERSION = '2.99_07';
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 37:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 38:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 39:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 40:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 41:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 42:	    UNKEYWORD UNSEEN/;
 115:	my @dow  = qw/Sun Mon Tue Wed Thu Fri Sat/;
 116:	my @mnt  = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/;
 2084:	my $thread_parser;
 2085:	sub thread
 2796:	1;
 392:	use Mail::IMAPClient;
 392:	use Mail::IMAPClient;
entering CODE(0x824fe1c)
 393:	use Digest::MD5  qw(md5_base64);
 393:	use Digest::MD5  qw(md5_base64);
 393:	use Digest::MD5  qw(md5_base64);
 entering Exporter::import
  30:	  my $pkg = shift;
  31:	  my $callpkg = caller($ExportLevel);
  33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  40:	  return export $pkg, $callpkg, @_
  41:	    if $Verbose or $Debug or @$fail > 1;
  42:	  my $export_cache = ($Cache{$pkg} ||= {});
  43:	  my $args = @_ or @_ = @$exports;
  45:	  local $_;
  46:	  if ($args and not %$export_cache) {
  50:	  my $heavy;
  53:	  if ($args or $fail) {
  54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
  55:	               or @$fail and $_ eq $fail->[0])) and last
  56:	                 foreach (@_);
  56:	                 foreach (@_);
  61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
  63:		sub {require Carp; &Carp::carp};
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
entering CODE(0x82274b4)
 396:	use MIME::Base64;
 396:	use MIME::Base64;
 396:	use MIME::Base64;
 entering Exporter::import
  30:	  my $pkg = shift;
  31:	  my $callpkg = caller($ExportLevel);
  33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  40:	  return export $pkg, $callpkg, @_
  41:	    if $Verbose or $Debug or @$fail > 1;
  42:	  my $export_cache = ($Cache{$pkg} ||= {});
  43:	  my $args = @_ or @_ = @$exports;
  45:	  local $_;
  46:	  if ($args and not %$export_cache) {
  50:	  my $heavy;
  53:	  if ($args or $fail) {
  54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
  55:	               or @$fail and $_ eq $fail->[0])) and last
  56:	                 foreach (@_);
  56:	                 foreach (@_);
  61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
  63:		sub {require Carp; &Carp::carp};
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
entering CODE(0x814f93c)
 397:	use English;
 entering CODE(0x85729e8)
  47:	no warnings;
  47:	no warnings;
  47:	no warnings;
  entering warnings::unimport
   251:	    shift;
   253:	    my $catmask ;
   254:	    my $mask = ${^WARNING_BITS} ;
   256:	    if (vec($mask, $Offsets{'all'}, 1)) {
   257:	        $mask |= $Bits{'all'} ;
   258:	        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
   261:	    push @_, 'all' unless @_;
   263:	    foreach my $word ( @_ ) {
   264:		if ($word eq 'FATAL') {
   268:		    $mask &= ~($catmask | $DeadBits{$word} | $All);
   274:	    ${^WARNING_BITS} = $mask ;
 Package /usr/share/perl/5.8/English.pm.
 3:	our $VERSION = '1.02';
 5:	require Exporter;
 6:	@ISA = (Exporter);
 49:	my $globbed_match ;
 77:	@MINIMAL_EXPORT = qw(
 78:		*ARG
 79:		*LAST_PAREN_MATCH
 80:		*INPUT_LINE_NUMBER
 81:		*NR
 82:		*INPUT_RECORD_SEPARATOR
 83:		*RS
 84:		*OUTPUT_AUTOFLUSH
 85:		*OUTPUT_FIELD_SEPARATOR
 86:		*OFS
 87:		*OUTPUT_RECORD_SEPARATOR
 88:		*ORS
 89:		*LIST_SEPARATOR
 90:		*SUBSCRIPT_SEPARATOR
 91:		*SUBSEP
 92:		*FORMAT_PAGE_NUMBER
 93:		*FORMAT_LINES_PER_PAGE
 94:		*FORMAT_LINES_LEFT
 95:		*FORMAT_NAME
 96:		*FORMAT_TOP_NAME
 97:		*FORMAT_LINE_BREAK_CHARACTERS
 98:		*FORMAT_FORMFEED
 99:		*CHILD_ERROR
 100:		*OS_ERROR
 101:		*ERRNO
 102:		*EXTENDED_OS_ERROR
 103:		*EVAL_ERROR
 104:		*PROCESS_ID
 105:		*PID
 106:		*REAL_USER_ID
 107:		*UID
 108:		*EFFECTIVE_USER_ID
 109:		*EUID
 110:		*REAL_GROUP_ID
 111:		*GID
 112:		*EFFECTIVE_GROUP_ID
 113:		*EGID
 114:		*PROGRAM_NAME
 115:		*PERL_VERSION
 116:		*ACCUMULATOR
 117:		*COMPILING
 118:		*DEBUGGING
 119:		*SYSTEM_FD_MAX
 120:		*INPLACE_EDIT
 121:		*PERLDB
 122:		*BASETIME
 123:		*WARNING
 124:		*EXECUTABLE_NAME
 125:		*OSNAME
 126:		*LAST_REGEXP_CODE_RESULT
 127:		*EXCEPTIONS_BEING_CAUGHT
 128:		*LAST_SUBMATCH_RESULT
 129:		@LAST_MATCH_START
 130:		@LAST_MATCH_END
 131:	);
 134:	@MATCH_EXPORT = qw(
 135:		*MATCH
 136:		*PREMATCH
 137:		*POSTMATCH
 138:	);
 140:	@COMPLETE_EXPORT = ( @MINIMAL_EXPORT, @MATCH_EXPORT ) ;
 144:		*ARG					= *_	;
 148:		*LAST_PAREN_MATCH			= *+	;
 149:		*LAST_SUBMATCH_RESULT			= *^N ;
 150:		*LAST_MATCH_START			= *-{ARRAY} ;
 151:		*LAST_MATCH_END				= *+{ARRAY} ;
 155:		*INPUT_LINE_NUMBER			= *.	;
 156:		    *NR					= *.	;
 157:		*INPUT_RECORD_SEPARATOR			= */	;
 158:		    *RS					= */	;
 162:		*OUTPUT_AUTOFLUSH			= *|	;
 163:		*OUTPUT_FIELD_SEPARATOR			= *,	;
 164:		    *OFS				= *,	;
 165:		*OUTPUT_RECORD_SEPARATOR		= *\	;
 166:		    *ORS				= *\	;
 170:		*LIST_SEPARATOR				= *"	;
 171:		*SUBSCRIPT_SEPARATOR			= *;	;
 172:		    *SUBSEP				= *;	;
 176:		*FORMAT_PAGE_NUMBER			= *%	;
 177:		*FORMAT_LINES_PER_PAGE			= *=	;
 178:		*FORMAT_LINES_LEFT			= *-	;
 179:		*FORMAT_NAME				= *~	;
 180:		*FORMAT_TOP_NAME			= *^	;
 181:		*FORMAT_LINE_BREAK_CHARACTERS		= *:	;
 182:		*FORMAT_FORMFEED			= *^L	;
 186:		*CHILD_ERROR				= *?	;
 187:		*OS_ERROR				= *!	;
 188:		    *ERRNO				= *!	;
 189:		*OS_ERROR				= *!	;
 190:		    *ERRNO				= *!	;
 191:		*EXTENDED_OS_ERROR			= *^E	;
 192:		*EVAL_ERROR				= *@	;
 196:		*PROCESS_ID				= *$	;
 197:		    *PID				= *$	;
 198:		*REAL_USER_ID				= *<	;
 199:		    *UID				= *<	;
 200:		*EFFECTIVE_USER_ID			= *>	;
 201:		    *EUID				= *>	;
 202:		*REAL_GROUP_ID				= *(	;
 203:		    *GID				= *(	;
 204:		*EFFECTIVE_GROUP_ID			= *)	;
 205:		    *EGID				= *)	;
 206:		*PROGRAM_NAME				= *0	;
 210:		*PERL_VERSION				= *^V	;
 211:		*ACCUMULATOR				= *^A	;
 212:		*COMPILING				= *^C	;
 213:		*DEBUGGING				= *^D	;
 214:		*SYSTEM_FD_MAX				= *^F	;
 215:		*INPLACE_EDIT				= *^I	;
 216:		*PERLDB					= *^P	;
 217:		*LAST_REGEXP_CODE_RESULT		= *^R	;
 218:		*EXCEPTIONS_BEING_CAUGHT		= *^S	;
 219:		*BASETIME				= *^T	;
 220:		*WARNING				= *^W	;
 221:		*EXECUTABLE_NAME			= *^X	;
 222:		*OSNAME					= *^O	;
 231:	1;
 397:	use English;
 397:	use English;
 entering English::import
  53:	    my $this = shift;
  54:	    my @list = grep { ! /^-no_match_vars$/ } @_ ;
  55:	    local $Exporter::ExportLevel = 1;
  56:	    if ( @_ == @list ) {
  57:	        *EXPORT = \@COMPLETE_EXPORT ;
  58:	        $globbed_match ||= (
  59:		    eval q{
  60:			*MATCH				= *&	;
  61:			*PREMATCH			= *`	;
  62:			*POSTMATCH			= *'	;
  63:			1 ;
  65:		    || do {
  2:			*MATCH				= *&	;
  3:			*PREMATCH			= *`	;
  4:			*POSTMATCH			= *'	;
  5:			1 ;
  74:	    Exporter::import($this,grep {s/^\$/*/} @list);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   entering Exporter::export
    26:	  goto &{as_heavy()};
    26:	  goto &{as_heavy()};
    entering Exporter::as_heavy
     17:	  require Exporter::Heavy;
     20:	  my $c = (caller(1))[3];
     21:	  $c =~ s/.*:://;
     22:	  \&{"Exporter::Heavy::heavy_$c"};
     22:	  \&{"Exporter::Heavy::heavy_$c"};
    39:	    };
    40:	    local $SIG{__DIE__} = sub {
    45:	    };
    47:	    my($pkg, $callpkg, @imports) = @_;
    48:	    my($type, $sym, $cache_is_current, $oops);
    49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
    50:	                                   $Exporter::Cache{$pkg} ||= {});
    49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
    50:	                                   $Exporter::Cache{$pkg} ||= {});
    52:	    if (@imports) {
    145:		@imports = @$exports;
    148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
    149:	                              $Exporter::FailCache{$pkg} ||= {});
    148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
    149:	                              $Exporter::FailCache{$pkg} ||= {});
    151:	    if (@$fail) {
    176:	    warn "Importing into $callpkg from $pkg: ",
    177:			join(", ",sort @imports) if $Exporter::Verbose;
    179:	    foreach $sym (@imports) {
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    186:		    $type eq '$' ? \${"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    186:		    $type eq '$' ? \${"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
    181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    182:		    unless $sym =~ s/^(\W)//;
    183:		$type = $1;
    190:		    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    188:		    $type eq '%' ? \%{"${pkg}::$sym"} :
    189:		    $type eq '*' ?  *{"${pkg}::$sym"} :
    184:		*{"${callpkg}::$sym"} =
entering CODE(0x824fdec)
 398:	use POSIX qw(uname);
 entering CODE(0x873278c)
  7:	use AutoLoader;
  entering CODE(0x87329b4)
   3:	use strict;
   3:	use strict;
   3:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x87329c0)
   4:	use 5.006_001;
   4:	use 5.006_001;
   4:	use 5.006_001;
  entering CODE(0x8732b40)
   14:	    $is_dosish = $^O eq 'dos' || $^O eq 'os2' || $^O eq 'MSWin32' || $^O eq 'NetWare';
   15:	    $is_epoc = $^O eq 'epoc';
   16:	    $is_vms = $^O eq 'VMS';
   17:	    $is_macos = $^O eq 'MacOS';
   18:	    $VERSION = '5.60';
  entering CODE(0x854a078)
   95:		    no strict 'refs';
   95:		    no strict 'refs';
   95:		    no strict 'refs';
   entering strict::unimport
    33:	    shift;
    34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
    entering strict::bits
     12:	    my $bits = 0;
     13:	    my @wrong;
     14:	    foreach my $s (@_) {
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     18:	    if (@wrong) {
     22:	    $bits;
  entering CODE(0x854a42c)
   128:		no strict 'refs';
   128:		no strict 'refs';
   128:		no strict 'refs';
   entering strict::unimport
    33:	    shift;
    34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
    entering strict::bits
     12:	    my $bits = 0;
     13:	    my @wrong;
     14:	    foreach my $s (@_) {
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     18:	    if (@wrong) {
     22:	    $bits;
  entering CODE(0x8744494)
   173:	    no strict 'refs';
   173:	    no strict 'refs';
   173:	    no strict 'refs';
   entering strict::unimport
    33:	    shift;
    34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
    entering strict::bits
     12:	    my $bits = 0;
     13:	    my @wrong;
     14:	    foreach my $s (@_) {
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     18:	    if (@wrong) {
     22:	    $bits;
  Package /usr/share/perl/5.8/AutoLoader.pm.
  6:	our($VERSION, $AUTOLOAD);
  8:	my $is_dosish;
  9:	my $is_epoc;
  10:	my $is_vms;
  11:	my $is_macos;
  179:	1;
  7:	use AutoLoader;
  7:	use AutoLoader;
  entering AutoLoader::import
   120:	    my $pkg = shift;
   121:	    my $callpkg = caller;
   127:	    if ($pkg eq 'AutoLoader') {
   129:		*{ $callpkg . '::AUTOLOAD' } = \&AUTOLOAD
   130:		    if @_ and $_[0] =~ /^&?AUTOLOAD$/;
   145:	    (my $calldir = $callpkg) =~ s#::#/#g;
   146:	    my $path = $INC{$calldir . '.pm'};
   147:	    if (defined($path)) {
   149:		if ($is_macos) {
   153:		    $path =~ s#^(.*)$calldir\.pm\z#$1auto/$calldir/autosplit.ix#;
   156:		eval { require $path; };
   156:		eval { require $path; };
   Package /usr/lib/perl/5.8/auto/POSIX/autosplit.ix.
   159:	1;
   158:		if ($@) {
   162:		if ($@) {
 entering CODE(0x87327f8)
  9:	use XSLoader ();
  9:	use XSLoader ();
  9:	use XSLoader ();
 entering CODE(0x8754634)
  56:	use AutoLoader 'AUTOLOAD';
  56:	use AutoLoader 'AUTOLOAD';
  56:	use AutoLoader 'AUTOLOAD';
  entering AutoLoader::import
   120:	    my $pkg = shift;
   121:	    my $callpkg = caller;
   127:	    if ($pkg eq 'AutoLoader') {
   129:		*{ $callpkg . '::AUTOLOAD' } = \&AUTOLOAD
   130:		    if @_ and $_[0] =~ /^&?AUTOLOAD$/;
   129:		*{ $callpkg . '::AUTOLOAD' } = \&AUTOLOAD
   130:		    if @_ and $_[0] =~ /^&?AUTOLOAD$/;
   145:	    (my $calldir = $callpkg) =~ s#::#/#g;
   146:	    my $path = $INC{$calldir . '.pm'};
   147:	    if (defined($path)) {
 Package /usr/lib/perl/5.8/POSIX.pm.
 3:	our(@ISA, %EXPORT_TAGS, @EXPORT_OK, $AUTOLOAD) = ();
 5:	our $VERSION = "1.09";
 12:	my $loaded;
 26:	XSLoader::load 'POSIX', $VERSION;
 entering XSLoader::load
  25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
  27:	    my($module) = $_[0];
  30:	    my $b = "$module\::bootstrap";
  31:	    goto &$b if defined &$b;
  33:	    goto retry unless $module and defined &dl_load_file;
  35:	    my @modparts = split(/::/,$module);
  36:	    my $modfname = $modparts[-1];
  38:	    my $modpname = join('/',@modparts);
  39:	    my $modlibname = (caller())[1];
  40:	    my $c = @modparts;
  41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
  42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
  46:	    my $bs = $file;
  47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
  49:	    goto retry if not -f $file or -s $bs;
  51:	    my $bootname = "boot_$module";
  52:	    $bootname =~ s/\W/_/g;
  53:	    @DynaLoader::dl_require_symbols = ($bootname);
  55:	    my $boot_symbol_ref;
  57:	    if ($^O eq 'darwin') {
  70:	    my $libref = dl_load_file($file, 0) or do { 
  entering DynaLoader::dl_load_file
  74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
  76:	    my @unresolved = dl_undef_symbols();
  entering DynaLoader::dl_undef_symbols
  77:	    if (@unresolved) {
  82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
  entering DynaLoader::dl_find_symbol
  87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
  89:	  boot:
  90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
  entering DynaLoader::dl_install_xsub
  93:	    return &$xs(@_);
  entering POSIX::bootstrap
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 28:	my %NON_CONSTS = (map {($_,1)}
 29:	                  qw(S_ISBLK S_ISCHR S_ISDIR S_ISFIFO S_ISREG WEXITSTATUS
 30:	                     WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG));
 61:	1;
 398:	use POSIX qw(uname);
 398:	use POSIX qw(uname);
 entering POSIX::import
  15:	    load_imports() unless $loaded++;
  entering POSIX::AUTOLOAD for POSIX::load_imports
   33:	    if ($AUTOLOAD =~ /::(_?[a-z])/) {
   35:		$AutoLoader::AUTOLOAD = $AUTOLOAD;
   36:		goto &AutoLoader::AUTOLOAD
   22:	    my $sub = $AUTOLOAD;
   23:	    my $filename;
   39:		my ($pkg,$func) = ($sub =~ /(.*)::([^:]+)$/);
   39:		my ($pkg,$func) = ($sub =~ /(.*)::([^:]+)$/);
   40:		$pkg =~ s#::#/#g;
   41:		if (defined($filename = $INC{"$pkg.pm"})) {
   42:		    if ($is_macos) {
   46:			$filename =~ s#^(.*)$pkg\.pm\z#$1auto/$pkg/$func.al#s;
   55:		    if (-r $filename) {
   56:			unless ($filename =~ m|^/|s) {
   84:		unless (defined $filename) {
   90:	    my $save = $@;
   91:	    local $!; # Do not munge the value. 
   92:	    eval { local $SIG{__DIE__}; require $filename };
   92:	    eval { local $SIG{__DIE__}; require $filename };
   92:	    eval { local $SIG{__DIE__}; require $filename };
   Package ../../lib/POSIX.pm (autosplit into ../../lib/auto/POSIX/load_imports.al).
   961:	1;
   93:	    if ($@) {
   115:	    $@ = $save;
   116:	    goto &$sub;
   744:	%EXPORT_TAGS = (
   894:	for (values %EXPORT_TAGS) {
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   895:	  push @EXPORT, @$_;
   898:	@EXPORT_OK = qw(
   899:			abs
   900:			alarm
   901:			atan2
   902:			chdir
   903:			chmod
   904:			chown
   905:			close
   906:			closedir
   907:			cos
   908:			exit
   909:			exp
   910:			fcntl
   911:			fileno
   912:			fork
   913:			getc
   914:			getgrgid
   915:			getgrnam
   916:			getlogin
   917:			getpgrp
   918:			getppid
   919:			getpwnam
   920:			getpwuid
   921:			gmtime
   922:			isatty
   923:			kill
   924:			lchown
   925:			link
   926:			localtime
   927:			log
   928:			mkdir
   929:			nice
   930:			open
   931:			opendir
   932:			pipe
   933:			printf
   934:			rand
   935:			read
   936:			readdir
   937:			rename
   938:			rewinddir
   939:			rmdir
   940:			sin
   941:			sleep
   942:			sprintf
   943:			sqrt
   944:			srand
   945:			stat
   946:			system
   947:			time
   948:			times
   949:			umask
   950:			unlink
   951:			utime
   952:			wait
   953:			waitpid
   954:			write
   955:	);
   957:	require Exporter;
  16:	    my $this = shift;
  17:	    my @list = map { m/^\w+_h$/ ? ":$_" : $_ } @_;
  17:	    my @list = map { m/^\w+_h$/ ? ":$_" : $_ } @_;
  18:	    local $Exporter::ExportLevel = 1;
  19:	    Exporter::import($this,@list);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
entering CODE(0x83582b8)
 399:	use Fcntl;
 399:	use Fcntl;
 399:	use Fcntl;
 entering Exporter::import
  30:	  my $pkg = shift;
  31:	  my $callpkg = caller($ExportLevel);
  33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  40:	  return export $pkg, $callpkg, @_
  41:	    if $Verbose or $Debug or @$fail > 1;
  42:	  my $export_cache = ($Cache{$pkg} ||= {});
  43:	  my $args = @_ or @_ = @$exports;
  45:	  local $_;
  46:	  if ($args and not %$export_cache) {
  50:	  my $heavy;
  53:	  if ($args or $fail) {
  54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
  55:	               or @$fail and $_ eq $fail->[0])) and last
  56:	                 foreach (@_);
  56:	                 foreach (@_);
  61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
  63:		sub {require Carp; &Carp::carp};
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
entering CODE(0x8793e94)
 438:	use vars qw ($opt_G); # missing code for this will be option.
 438:	use vars qw ($opt_G); # missing code for this will be option.
 438:	use vars qw ($opt_G); # missing code for this will be option.
 entering vars::import
  11:	    my $callpack = caller;
  12:	    my ($pack, @imports) = @_;
  13:	    my ($sym, $ch);
  14:	    foreach (@imports) {
  15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
  16:		    if ($sym =~ /\W/) {
  28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
  29:		    *$sym =
  30:			(  $ch eq "\$" ? \$$sym
  31:			 : $ch eq "\@" ? \@$sym
  32:			 : $ch eq "\%" ? \%$sym
  33:			 : $ch eq "\*" ? \*$sym
  34:			 : $ch eq "\&" ? \&$sym 
  35:			 : do {
Package ./imapsync.
389:	++$|;
401:	eval { require 'usr/include/sysexits.ph' };
401:	eval { require 'usr/include/sysexits.ph' };
Package /usr/local/lib/perl/5.8.0/usr/include/sysexits.ph.
1:	require '_h2ph_pre.ph';
Package /usr/lib/perl/5.8/_h2ph_pre.ph.
2:	unless (defined &_FILE_OFFSET_BITS) { sub _FILE_OFFSET_BITS() { 64 } }
4:	unless (defined &_GNU_SOURCE) { sub _GNU_SOURCE() { 1 } }
6:	unless (defined &_LARGEFILE64_SOURCE) { sub _LARGEFILE64_SOURCE() { 1 } }
8:	unless (defined &_LARGEFILE_SOURCE) { sub _LARGEFILE_SOURCE() { 1 } }
10:	unless (defined &_POSIX_C_SOURCE) { sub _POSIX_C_SOURCE() { 199506 } }
12:	unless (defined &_POSIX_SOURCE) { sub _POSIX_SOURCE() { 1 } }
14:	unless (defined &_REENTRANT) { sub _REENTRANT() { 1 } }
16:	unless (defined &_XOPEN_SOURCE) { sub _XOPEN_SOURCE() { 600 } }
18:	unless (defined &_XOPEN_SOURCE_EXTENDED) { sub _XOPEN_SOURCE_EXTENDED() { 1 } }
20:	unless (defined &__ELF__) { sub __ELF__() { 1 } }
22:	unless (defined &__GLIBC_MINOR__) { sub __GLIBC_MINOR__() { 3 } }
24:	unless (defined &__GLIBC__) { sub __GLIBC__() { 2 } }
26:	unless (defined &__GNUC_MINOR__) { sub __GNUC_MINOR__() { 1 } }
28:	unless (defined &__GNUC__) { sub __GNUC__() { 4 } }
30:	unless (defined &__GNU_LIBRARY__) { sub __GNU_LIBRARY__() { 6 } }
32:	unless (defined &__STDC__) { sub __STDC__() { 1 } }
34:	unless (defined &__USE_BSD) { sub __USE_BSD() { 1 } }
36:	unless (defined &__USE_FILE_OFFSET64) { sub __USE_FILE_OFFSET64() { 1 } }
38:	unless (defined &__USE_GNU) { sub __USE_GNU() { 1 } }
40:	unless (defined &__USE_LARGEFILE) { sub __USE_LARGEFILE() { 1 } }
42:	unless (defined &__USE_LARGEFILE64) { sub __USE_LARGEFILE64() { 1 } }
44:	unless (defined &__USE_MISC) { sub __USE_MISC() { 1 } }
46:	unless (defined &__USE_POSIX) { sub __USE_POSIX() { 1 } }
48:	unless (defined &__USE_POSIX199309) { sub __USE_POSIX199309() { 1 } }
50:	unless (defined &__USE_POSIX199506) { sub __USE_POSIX199506() { 1 } }
52:	unless (defined &__USE_POSIX2) { sub __USE_POSIX2() { 1 } }
54:	unless (defined &__USE_REENTRANT) { sub __USE_REENTRANT() { 1 } }
56:	unless (defined &__USE_SVID) { sub __USE_SVID() { 1 } }
58:	unless (defined &__USE_UNIX98) { sub __USE_UNIX98() { 1 } }
60:	unless (defined &__USE_XOPEN) { sub __USE_XOPEN() { 1 } }
62:	unless (defined &__USE_XOPEN_EXTENDED) { sub __USE_XOPEN_EXTENDED() { 1 } }
64:	unless (defined &__i386) { sub __i386() { 1 } }
66:	unless (defined &__i386__) { sub __i386__() { 1 } }
68:	unless (defined &__i486) { sub __i486() { 1 } }
70:	unless (defined &__i486__) { sub __i486__() { 1 } }
72:	unless (defined &__linux) { sub __linux() { 1 } }
74:	unless (defined &__linux__) { sub __linux__() { 1 } }
76:	unless (defined &__unix) { sub __unix() { 1 } }
78:	unless (defined &__unix__) { sub __unix__() { 1 } }
80:	unless (defined &i386) { sub i386() { 1 } }
82:	unless (defined &linux) { sub linux() { 1 } }
84:	unless (defined &unix) { sub unix() { 1 } }
87:	unless (defined &__LONG_MAX__) { sub __LONG_MAX__ { 2147483647 } }
3:	unless(defined(&_SYSEXITS_H)) {
4:	    eval 'sub _SYSEXITS_H () {1;}' unless defined(&_SYSEXITS_H);
5:	    eval 'sub EX_OK () {0;}' unless defined(&EX_OK);
6:	    eval 'sub EX__BASE () {64;}' unless defined(&EX__BASE);
7:	    eval 'sub EX_USAGE () {64;}' unless defined(&EX_USAGE);
8:	    eval 'sub EX_DATAERR () {65;}' unless defined(&EX_DATAERR);
9:	    eval 'sub EX_NOINPUT () {66;}' unless defined(&EX_NOINPUT);
10:	    eval 'sub EX_NOUSER () {67;}' unless defined(&EX_NOUSER);
11:	    eval 'sub EX_NOHOST () {68;}' unless defined(&EX_NOHOST);
12:	    eval 'sub EX_UNAVAILABLE () {69;}' unless defined(&EX_UNAVAILABLE);
13:	    eval 'sub EX_SOFTWARE () {70;}' unless defined(&EX_SOFTWARE);
14:	    eval 'sub EX_OSERR () {71;}' unless defined(&EX_OSERR);
15:	    eval 'sub EX_OSFILE () {72;}' unless defined(&EX_OSFILE);
16:	    eval 'sub EX_CANTCREAT () {73;}' unless defined(&EX_CANTCREAT);
17:	    eval 'sub EX_IOERR () {74;}' unless defined(&EX_IOERR);
18:	    eval 'sub EX_TEMPFAIL () {75;}' unless defined(&EX_TEMPFAIL);
19:	    eval 'sub EX_PROTOCOL () {76;}' unless defined(&EX_PROTOCOL);
20:	    eval 'sub EX_NOPERM () {77;}' unless defined(&EX_NOPERM);
21:	    eval 'sub EX_CONFIG () {78;}' unless defined(&EX_CONFIG);
22:	    eval 'sub EX__MAX () {78;}' unless defined(&EX__MAX);
24:	1;
405:	        $rcs, $debug, $debugimap, $error,
406:		$host1, $host2, $port1, $port2,
407:		$user1, $user2, $password1, $password2, $passfile1, $passfile2,
408:	        @folder, @include, @exclude, @folderrec,
409:	        $prefix1, $prefix2, 
410:	        @regextrans2, @regexmess, @regexflag, 
411:	        $sep1, $sep2,
412:		$syncinternaldates, $syncacls,
413:	        $fastio1, $fastio2, 
414:		$maxsize, $maxage, $minage, 
415:	        $skipheader, @useheader,
416:	        $skipsize, $foldersizes, $buffersize,
417:		$delete, $delete2,
418:	        $expunge, $expunge1, $expunge2, $dry,
419:	        $justfoldersizes,
420:	        $authmd5,
421:	        $subscribed, $subscribe,
422:		$version, $VERSION, $help, 
423:	        $justconnect, $justfolders,
424:	        $fast,
425:	        $mess_size_total_trans,
426:	        $mess_size_total_skipped,
427:	        $mess_size_total_error,
428:	        $mess_trans, $mess_skipped, $mess_skipped_dry, 
429:	        $timeout,   # whr (ESS/PRW)
430:		$timestart, $timeend, $timediff,
431:	        $timesize, $timebefore,
432:	        $ssl1, $ssl2,
433:	        $authuser1, $authuser2,
434:	        $authmech1, $authmech2,
435:	        $split1, $split2,
436:	);
441:	$rcs = ' $Id: imapsync,v 1.235 2007/11/10 02:52:29 gilles Exp gilles $ ';
442:	$rcs =~ m/,v (\d+\.\d+)/;
443:	$VERSION = ($1) ? $1 : "UNKNOWN";
445:	my $VERSION_IMAPClient = $Mail::IMAPClient::VERSION;
451:	$mess_size_total_trans   = 0;
452:	$mess_size_total_skipped = 0;
453:	$mess_size_total_error   = 0;
454:	$mess_trans = $mess_skipped = $mess_skipped_dry = 0;
475:	$error=0;
477:	my $banner = join("", 
478:			  '$RCSfile: imapsync,v $ ',
479:			  '$Revision: 1.235 $ ',
480:			  '$Date: 2007/11/10 02:52:29 $ ',
481:			  "\n",localhost_info(),
482:			  " and the module Mail::IMAPClient version used here is ",
483:			  $VERSION_IMAPClient,"\n",
484:			  "Command line used :\n",
485:			  "$0 @ARGV\n",
486:			 );
entering main::localhost_info
 525:		my($infos) = join("", 
 526:		"Here is a [$OSNAME] system (", 
 527:		join(" ", 
 528:		     uname(),
 529:		),
 530:	        ")\n",
 531:		"with perl ", 
 532:		sprintf("%vd", $PERL_VERSION));		  
 entering POSIX::uname
 533:		return($infos);
488:	unless(defined(&_SYSEXITS_H)) {
493:	get_options();
entering main::get_options
 1386:		my $numopt = scalar(@ARGV);
 1387:	        my $opt_ret = GetOptions(
 1388:	                                   "debug!"       => \$debug,
 1389:	                                   "debugimap!"   => \$debugimap,
 1390:	                                   "host1=s"     => \$host1,
 1391:	                                   "host2=s"     => \$host2,
 1392:	                                   "port1=i"     => \$port1,
 1393:	                                   "port2=i"     => \$port2,
 1394:	                                   "user1=s"     => \$user1,
 1395:	                                   "user2=s"     => \$user2,
 1396:	                                   "password1=s" => \$password1,
 1397:	                                   "password2=s" => \$password2,
 1398:	                                   "passfile1=s" => \$passfile1,
 1399:	                                   "passfile2=s" => \$passfile2,
 1400:					   "authmd5!"    => \$authmd5,
 1401:	                                   "sep1=s"      => \$sep1,
 1402:	                                   "sep2=s"      => \$sep2,
 1403:					   "folder=s"    => \@folder,
 1404:					   "folderrec=s" => \@folderrec,
 1405:					   "include=s"   => \@include,
 1406:					   "exclude=s"   => \@exclude,
 1407:					   "prefix1=s"   => \$prefix1,
 1408:					   "prefix2=s"   => \$prefix2,
 1409:					   "regextrans2=s" => \@regextrans2,
 1410:					   "regexmess=s" => \@regexmess,
 1411:					   "regexflag=s" => \@regexflag,
 1412:	                                   "delete!"     => \$delete,
 1413:	                                   "delete2!"    => \$delete2,
 1414:	                                   "syncinternaldates!" => \$syncinternaldates,
 1415:	                                   "syncacls!"   => \$syncacls,
 1416:					   "maxsize=i"   => \$maxsize,
 1417:					   "maxage=i"    => \$maxage,
 1418:					   "minage=i"    => \$minage,
 1419:					   "buffersize=i" => \$buffersize,
 1420:					   "foldersizes!" => \$foldersizes,
 1421:	                                   "dry!"        => \$dry,
 1422:	                                   "expunge!"    => \$expunge,
 1423:	                                   "expunge1!"    => \$expunge1,
 1424:	                                   "expunge2!"    => \$expunge2,
 1425:	                                   "subscribed!" => \$subscribed,
 1426:	                                   "subscribe!"  => \$subscribe,
 1427:	                                   "justconnect!"=> \$justconnect,
 1428:	                                   "justfolders!"=> \$justfolders,
 1429:					   "justfoldersizes!" => \$justfoldersizes,
 1430:					   "fast!"       => \$fast,
 1431:	                                   "version"     => \$version,
 1432:	                                   "help"        => \$help,
 1433:	                                   "timeout=i"   => \$timeout,
 1434:					   "skipheader=s" => \$skipheader,
 1435:					   "useheader=s" => \@useheader,
 1436:					   "skipsize!"   => \$skipsize,
 1437:					   "fastio1!"     => \$fastio1,
 1438:					   "fastio2!"     => \$fastio2,
 1439:					   "ssl1!"        => \$ssl1,
 1440:					   "ssl2!"        => \$ssl2,
 1441:					   "authmech1=s" => \$authmech1,
 1442:					   "authmech2=s" => \$authmech2,
 1443:					   "authuser1=s" => \$authuser1,
 1444:					   "authuser2=s" => \$authuser2,
 1445:					   "split1=i"    => \$split1,
 1446:					   "split2=i"    => \$split2,
 1447:	                                  );
 entering Getopt::Long::GetOptions
  252:	    my @optionlist = @_;	# local copy of the option descriptions
  253:	    my $argend = '--';		# option list terminator
  254:	    my %opctl = ();		# table of option specs
  255:	    my $pkg = $caller || (caller)[0];	# current context
  257:	    my @ret = ();		# accum for non-options
  258:	    my %linkage;		# linkage
  259:	    my $userlinkage;		# user supplied HASH
  260:	    my $opt;			# current option
  261:	    my $prefix = $genprefix;	# current prefix
  263:	    $error = '';
  265:	    if ( $debug ) {
  292:	    $userlinkage = undef;
  293:	    if ( @optionlist && ref($optionlist[0]) and
  294:		 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  302:	    if ( @optionlist && $optionlist[0] =~ /^\W+$/
  303:		 && !($optionlist[0] eq '<>'
  304:		      && @optionlist > 0
  305:		      && ref($optionlist[1])) ) {
  314:	    %opctl = ();
  315:	    while ( @optionlist ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  381:			$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   773:		$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   826:		    $opctl->{"no$_"} = $entry;
   827:		    $opctl->{"no-$_"} = $entry;
   828:		    $opctl->{$_} = [@$entry];
   829:		    $opctl->{$_}->[CTL_TYPE] = '';
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  316:		my $opt = shift (@optionlist);
  318:		unless ( defined($opt) ) {
  324:		$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  326:		if ( $opt eq '<>' ) {
  346:		my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  entering Getopt::Long::ParseOptionSpec
   724:	    my ($opt, $opctl) = @_;
   727:	    if ( $opt !~ m;^
   728:			   (
   748:	    my ($names, $spec) = ($1, $2);
   749:	    $spec = '' unless defined $spec;
   757:	    my $orig;
   759:	    my @names;
   760:	    if ( defined $names ) {
   761:		@names =  split (/\|/, $names);
   762:		$orig = $names[0];
   770:	    my $entry;
   771:	    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
   787:		my ($mand, $type, $dest) =
   788:		  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
   789:		return (undef, "Cannot repeat while bundling: \"$opt\"\n")
   790:		  if $bundling && defined($4);
   791:		my ($mi, $cm, $ma) = ($5, $6, $7);
   792:		return (undef, "{0} is useless in option spec: \"$opt\"\n")
   793:		  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
   795:		$type = 'i' if $type eq 'n';
   796:		$dest ||= '$';
   797:		$dest = $dest eq '@' ? CTL_DEST_ARRAY
   798:		  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
   800:		$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
   802:		$mand = $mi ? '=' : ':';
   804:		$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
   805:		return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
   806:		  if defined($ma) && !$ma;
   807:		return (undef, "Max less than min in option spec: \"$opt\"\n")
   808:		  if defined($ma) && $ma < $mi;
   811:		$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
   815:	    my $dups = '';
   816:	    foreach ( @names ) {
   818:		$_ = lc ($_)
   819:		  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
   821:		if ( exists $opctl->{$_} ) {
   825:		if ( $spec eq '!' ) {
   832:		    $opctl->{$_} = $entry;
   836:	    if ( $dups && $^W ) {
   841:	    ($names[0], $orig);
  347:		unless ( defined $name ) {
  358:		if ( defined $userlinkage ) {
  375:		if ( @optionlist > 0 && ref($optionlist[0]) ) {
  376:		    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  377:			if $debug;
  378:		    my $rl = ref($linkage{$orig} = shift (@optionlist));
  380:		    if ( $rl eq "ARRAY" ) {
  428:	    die ($error) if $error;
  429:	    $error = 0;
  432:	    if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  439:	    if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  448:	    if ( $debug ) {
  458:	    my $goon = 1;
  459:	    while ( $goon && @ARGV > 0 ) {
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   1006:	    my $mand = $ctl->[CTL_AMIN];
   1009:	    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
   1015:	    if ( defined $optarg
   1016:		 ? ($optarg eq '')
   1017:		 : !(defined $rest || @ARGV > 0) ) {
   1037:	    $arg = (defined $rest ? $rest
   1038:		    : (defined $optarg ? $optarg : shift (@ARGV)));
   1041:	    my $key;
   1042:	    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
   1057:	    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
   1059:	    if ( $type eq 's' ) {	# string
   1061:		return (1, $opt, $ctl, $arg, $key) if $mand;
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   1006:	    my $mand = $ctl->[CTL_AMIN];
   1009:	    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
   1015:	    if ( defined $optarg
   1016:		 ? ($optarg eq '')
   1017:		 : !(defined $rest || @ARGV > 0) ) {
   1037:	    $arg = (defined $rest ? $rest
   1038:		    : (defined $optarg ? $optarg : shift (@ARGV)));
   1041:	    my $key;
   1042:	    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
   1057:	    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
   1059:	    if ( $type eq 's' ) {	# string
   1061:		return (1, $opt, $ctl, $arg, $key) if $mand;
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   1006:	    my $mand = $ctl->[CTL_AMIN];
   1009:	    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
   1015:	    if ( defined $optarg
   1016:		 ? ($optarg eq '')
   1017:		 : !(defined $rest || @ARGV > 0) ) {
   1037:	    $arg = (defined $rest ? $rest
   1038:		    : (defined $optarg ? $optarg : shift (@ARGV)));
   1041:	    my $key;
   1042:	    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
   1057:	    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
   1059:	    if ( $type eq 's' ) {	# string
   1061:		return (1, $opt, $ctl, $arg, $key) if $mand;
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   1006:	    my $mand = $ctl->[CTL_AMIN];
   1009:	    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
   1015:	    if ( defined $optarg
   1016:		 ? ($optarg eq '')
   1017:		 : !(defined $rest || @ARGV > 0) ) {
   1037:	    $arg = (defined $rest ? $rest
   1038:		    : (defined $optarg ? $optarg : shift (@ARGV)));
   1041:	    my $key;
   1042:	    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
   1057:	    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
   1059:	    if ( $type eq 's' ) {	# string
   1061:		return (1, $opt, $ctl, $arg, $key) if $mand;
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   1006:	    my $mand = $ctl->[CTL_AMIN];
   1009:	    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
   1015:	    if ( defined $optarg
   1016:		 ? ($optarg eq '')
   1017:		 : !(defined $rest || @ARGV > 0) ) {
   1037:	    $arg = (defined $rest ? $rest
   1038:		    : (defined $optarg ? $optarg : shift (@ARGV)));
   1041:	    my $key;
   1042:	    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
   1057:	    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
   1059:	    if ( $type eq 's' ) {	# string
   1061:		return (1, $opt, $ctl, $arg, $key) if $mand;
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   1006:	    my $mand = $ctl->[CTL_AMIN];
   1009:	    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
   1015:	    if ( defined $optarg
   1016:		 ? ($optarg eq '')
   1017:		 : !(defined $rest || @ARGV > 0) ) {
   1037:	    $arg = (defined $rest ? $rest
   1038:		    : (defined $optarg ? $optarg : shift (@ARGV)));
   1041:	    my $key;
   1042:	    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
   1057:	    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
   1059:	    if ( $type eq 's' ) {	# string
   1061:		return (1, $opt, $ctl, $arg, $key) if $mand;
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   987:		if ( defined $optarg ) {
   998:		    $opt =~ s/^no-?//i;	# strip NO prefix
   999:		    $arg = 0;		# supply explicit value
   1001:		unshift (@ARGV, $starter.$rest) if defined $rest;
   1002:		return (1, $opt, $ctl, $arg);
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   987:		if ( defined $optarg ) {
   995:		    $arg = 1;
   1001:		unshift (@ARGV, $starter.$rest) if defined $rest;
   1002:		return (1, $opt, $ctl, $arg);
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   987:		if ( defined $optarg ) {
   995:		    $arg = 1;
   1001:		unshift (@ARGV, $starter.$rest) if defined $rest;
   1002:		return (1, $opt, $ctl, $arg);
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  462:		$opt = shift (@ARGV);
  463:		print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  466:		if ( $opt eq $argend ) {
  472:		my $tryopt = $opt;
  473:		my $found;		# success status
  474:		my $key;		# key (if hash type)
  475:		my $arg;		# option argument
  476:		my $ctl;		# the opctl entry
  478:		($found, $opt, $ctl, $arg, $key) =
  479:		  FindOption ($prefix, $argend, $opt, \%opctl);
  entering Getopt::Long::FindOption
   851:	    my ($prefix, $argend, $opt, $opctl) = @_;
   853:	    print STDERR ("=> find \"$opt\"\n") if $debug;
   855:	    return (0) unless $opt =~ /^$prefix(.*)$/s;
   856:	    return (0) if $opt eq "-" && !defined $opctl->{''};
   858:	    $opt = $+;
   859:	    my $starter = $1;
   861:	    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
   863:	    my $optarg;			# value supplied with --opt=value
   864:	    my $rest;			# remainder from unbundling
   868:	    if ( ($starter=~/^$longprefix$/
   869:	          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
   870:		  && $opt =~ /^([^=]+)=(.*)$/s ) {
   879:	    my $tryopt = $opt;		# option to try
   881:	    if ( $bundling && $starter eq '-' ) {
   907:		my @names = sort(keys (%$opctl));
   909:		$opt = lc ($opt) if $ignorecase;
   910:		$tryopt = $opt;
   912:		my $pat = quotemeta ($opt);
   914:		my @hits = grep (/^$pat/, @names);
   915:		print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
   916:			      "out of ", scalar(@names), "\n") if $debug;
   919:		unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
   949:		if ( @hits == 1 && $hits[0] ne $opt ) {
   963:	    my $ctl = $opctl->{$tryopt};
   964:	    unless  ( defined $ctl ) {
   976:	    $opt = $tryopt;
   977:	    print STDERR ("=> found ", OptCtl($ctl),
   978:			  " for \"", $opt, "\"\n") if $debug;
   983:	    my $type = $ctl->[CTL_TYPE];
   984:	    my $arg;
   986:	    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
   987:		if ( defined $optarg ) {
   995:		    $arg = 1;
   1001:		unshift (@ARGV, $starter.$rest) if defined $rest;
   1002:		return (1, $opt, $ctl, $arg);
  481:		if ( $found ) {
  484:		    next unless defined $opt;
  486:		    my $argcnt = 0;
  487:		    while ( defined $arg ) {
  490:			print STDERR ("=> cname for \"$opt\" is ") if $debug;
  491:			$opt = $ctl->[CTL_CNAME];
  492:			print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  494:			if ( defined $linkage{$opt} ) {
  495:			    print STDERR ("=> ref(\$L{$opt}) -> ",
  496:					  ref($linkage{$opt}), "\n") if $debug;
  498:			    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
  499:				if ( $ctl->[CTL_TYPE] eq '+' ) {
  530:				    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  531:				      if $debug;
  532:				    ${$linkage{$opt}} = $arg;
  532:				    ${$linkage{$opt}} = $arg;
  620:			$argcnt++;
  621:			last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  695:	    if ( @ret && $order == $PERMUTE ) {
  702:	    return ($error == 0);
 1449:	        $debug and print "get options: [$opt_ret]\n";
 1452:	        print "$VERSION\n" and exit if ($version) ;
 1455:	        usage() and exit if ($help or ! $numopt) ;
 1458:	        exit(EX_USAGE()) unless ($opt_ret) ;
494:	print $banner;
502:	$split1 ||= 1000;
503:	$split2 ||= 1000;
505:	$host1 || missing_option("--host1") ;
507:	$port1 ||= defined $ssl1 ? 993 : 143;
509:	$host2 || missing_option("--host2") ;
511:	$port2 ||= defined $ssl2 ? 993 : 143;
537:	if ($justconnect) {
552:	$user1 || missing_option("--user1");
553:	$user2 || missing_option("--user2");
555:	if(defined($authmd5) and not($authmd5)) {
556:		$authmech1 ||= 'LOGIN';
557:		$authmech2 ||= 'LOGIN';
564:	$authmech1 = uc($authmech1);
565:	$authmech2 = uc($authmech2);
567:	$authuser1 ||= $user1;
568:	$authuser2 ||= $user2;
570:	print "will try to use $authmech1 authentication on host1\n";
571:	print "will try to use $authmech2 authentication on host2\n";
573:	$syncacls = (defined($syncacls)) ? $syncacls : 0;
574:	$foldersizes = (defined($foldersizes)) ? $foldersizes : 1;
576:	$fastio1 = (defined($fastio1)) ? $fastio1 : 0;
577:	$fastio2 = (defined($fastio2)) ? $fastio2 : 0;
580:	@useheader = ("ALL") unless (@useheader);
582:	print "From imap server [$host1] port [$port1] user [$user1]\n";
583:	print "To   imap server [$host2] port [$port2] user [$user2]\n";
599:	$password1 || $passfile1 || do {
603:	$password1 = (defined($passfile1)) ? firstline ($passfile1) : $password1;
entering main::firstline
 1521:	        my($file) = @_;
 1522:	        my $line  = "";
 1524:	        open FILE, $file or die("error [$file]: $! ");
 1525:	        chomp($line = <FILE>);
 1526:	        close FILE;
 1527:	        $line = ($line) ? $line : "error !EMPTY! [$file]";
 1528:	        return $line;
605:	$password2 || $passfile2 || do {
609:	$password2 = (defined($passfile2)) ? firstline ($passfile2) : $password2;
entering main::firstline
 1521:	        my($file) = @_;
 1522:	        my $line  = "";
 1524:	        open FILE, $file or die("error [$file]: $! ");
 1525:	        chomp($line = <FILE>);
 1526:	        close FILE;
 1527:	        $line = ($line) ? $line : "error !EMPTY! [$file]";
 1528:	        return $line;
611:	my $from = ();
612:	my $to = ();
614:	$timestart = time();
615:	$timebefore = $timestart;
617:	$debugimap and print "From connection\n";
618:	$from = login_imap($host1, $port1, $user1, $password1, 
619:			   $debugimap, $timeout, $fastio1, $ssl1, 
620:			   $authmech1, $authuser1);
entering main::login_imap
 634:		my($host, $port, $user, $password, 
 635:		   $debugimap, $timeout, $fastio, 
 636:		   $ssl, $authmech, $authuser) = @_;
 637:		my ($imap);
 638:		if ($ssl) {
 650:			$imap = Mail::IMAPClient->new();
 entering Mail::IMAPClient::new
  185:	{   my $class = shift;
  186:	    my $self  =
  187:	      { LastError     => "",
  188:	      , Uid           => 1
  189:	      , Count         => 0
  190:	      , Fast_io       => 1
  191:	      , Clear         => 5
  192:	      , Maxtemperrors => 'unlimited'
  193:	      , State         => Unconnected
  194:	      , Authmechanism => 'LOGIN'
  195:	      , Port          => 143
  196:	      , Timeout       => 30
  197:	      , History       => {}
  199:	    while(@_)
  204:	    bless $self, ref($class)||$class;
  206:	    if(my $sup = $self->{Supportedflags})  # unpack into case-less HASH
  211:	    $self->{Debug_fh} ||= \*STDERR;
  212:	    CORE::select((select($self->{Debug_fh}),$|++)[0]);
  214:	    if($self->Debug)
  entering CODE(0x83d611c)
   64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  219:	    $self->Socket($self->{Socket})
  220:	        if $self->{Socket};
  222:	    if($self->{Rawsocket})
  223:	    {
  229:	    !$self->{Socket} && $self->{Server} ?  $self->connect : $self;
 652:		$imap->Clear(20);
 entering Mail::IMAPClient::Clear
  165:	{   my ($self, $clear) = @_;
  166:	    defined $clear or return $self->{Clear};
  168:	    my $oldclear   = $self->{Clear};
  169:	    $self->{Clear} = $clear;
  171:	    my @keys = reverse $self->_trans_index;
  entering Mail::IMAPClient::_trans_index
   1452:	sub _trans_index()   { sort {$a <=> $b} keys %{$_[0]->{History}} }
   1452:	sub _trans_index()   { sort {$a <=> $b} keys %{$_[0]->{History}} }
  175:	    }
  173:	    for(my $i = $clear; $i < @keys ; $i++ )
  177:	    $oldclear;
 653:		$imap->Server($host);
 entering CODE(0x83d5dd4)
  64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
 654:		$imap->Port($port);
 entering CODE(0x83d5d5c)
  64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
 655:		$imap->Fast_io($fastio);
 entering Mail::IMAPClient::Fast_io
  78:	{   my ($self, $use) = @_;
  79:	    defined $use
  80:	       or return $self->{File_io};
  82:	    my $socket = $self->{Socket}
  83:	       or return;
 656:		$imap->Buffer($buffersize || 4096);
 entering CODE(0x83d60a4)
  64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
 657:		$imap->Uid(1);
 entering CODE(0x83d620c)
  64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
 658:		$imap->Peek(1);
 entering CODE(0x83d5ec4)
  64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
 659:		$imap->Debug($debugimap);
 entering CODE(0x83d611c)
  64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
 660:		$timeout and $imap->Timeout($timeout);
 662:		if ($ssl) {
 666:			$imap->connect2()
 667:		  or die "Can not open imap connection on [$host] with user [$user] : $@\n";
 entering Mail::IMAPClient::connect2
  2185:		my $self = shift;
  2187:		$self->Port(143) 
  2188:			if 	defined ($IO::Socket::INET::VERSION) 
  2189:			and 	$IO::Socket::INET::VERSION eq '1.25' 
  2190:			and 	!$self->Port;
  2191:		%$self = (%$self, @_);
  2192:		my $sock = ($self->Ssl ? IO::Socket::SSL->new : IO::Socket::INET->new);
  entering Mail::IMAPClient::Ssl
   2180:	sub Ssl {
  entering IO::Socket::INET::new
   30:	    my $class = shift;
   31:	    unshift(@_, "PeerAddr") if @_ == 1;
   32:	    return $class->SUPER::new(@_);
   entering IO::Socket::new
    41:	    my($class,%arg) = @_;
    42:	    my $sock = $class->SUPER::new();
    entering IO::Handle::new
     53:	    my $class = ref($_[0]) || $_[0] || "IO::Handle";
     54:	    @_ == 1 or croak "usage: new $class";
     55:	    my $io = gensym;
     entering Symbol::gensym
      23:	    my $name = "GEN" . $genseq++;
      24:	    my $ref = \*{$genpkg . $name};
      24:	    my $ref = \*{$genpkg . $name};
      25:	    delete $$genpkg{$name};
      26:	    $ref;
     56:	    bless $io, $class;
    44:	    $sock->autoflush(1);
    entering IO::Handle::autoflush
     213:	    my $old = new SelectSaver qualify($_[0], caller);
     entering Symbol::qualify
      39:	    my ($name) = @_;
      40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
      53:	    $name;
     entering SelectSaver::new
      10:	    @_ >= 1 && @_ <= 2 or croak 'usage: new SelectSaver [FILEHANDLE]';
      11:	    my $fh = select;
      12:	    my $self = bless \$fh, $_[0];
      13:	    select qualify($_[1], caller) if @_ > 1;
      entering Symbol::qualify
       39:	    my ($name) = @_;
       40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
       53:	    $name;
      14:	    $self;
     214:	    my $prev = $|;
     215:	    $| = @_ > 1 ? $_[1] : 1;
     216:	    $prev;
     entering SelectSaver::DESTROY
      18:	    my $self = $_[0];
      19:	    select $$self;
    46:	    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
    46:	    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
    48:	    return scalar(%arg) ? $sock->configure(\%arg)
    49:				: $sock;
  2193:		my $dp = ($self->Ssl ? 'imaps(993)' : 'imap(143)');
  entering Mail::IMAPClient::Ssl
   2180:	sub Ssl {
  2195:		my $ret = $sock->configure({
  2196:			PeerAddr => $self->Server		,
  2197:	                PeerPort => $self->Port||$dp	       	,
  2198:	                Proto    => 'tcp' 			,
  2199:	                Timeout  => $self->Timeout||0		,
  2200:			Debug	=> $self->Debug 		,
  entering CODE(0x83d5dd4)
   64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  entering CODE(0x83d5d5c)
   64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  entering CODE(0x83d602c)
   64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  entering CODE(0x83d611c)
   64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  entering IO::Socket::INET::configure
   104:	    my($sock,$arg) = @_;
   105:	    my($lport,$rport,$laddr,$raddr,$proto,$type);
   107:	    $arg->{LocalAddr} = $arg->{LocalHost}
   108:		if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};
   110:	    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
   111:						$arg->{LocalPort},
   112:						$arg->{Proto})
   113:				or return _error($sock, $!, $@);
   entering IO::Socket::INET::_sock_info
    36:	  my($addr,$port,$proto) = @_;
    37:	  my $origport = $port;
    38:	  my @proto = ();
    39:	  my @serv = ();
    41:	  $port = $1
    42:		if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
    44:	  if(defined $proto  && $proto =~ /\D/) {
    45:	    if(@proto = getprotobyname($proto)) {
    46:	      $proto = $proto[2] || undef;
    54:	  if(defined $port) {
    71:	 return ($addr || undef,
    72:		 $port || undef,
    73:		 $proto || undef
    74:		);
   115:	    $laddr = defined $laddr ? inet_aton($laddr)
   116:				    : INADDR_ANY;
   entering Socket::AUTOLOAD for Socket::INADDR_ANY
    216:	    my($constname);
    217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
    218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
    219:	    my ($error, $val) = constant($constname);
    entering Socket::constant
    220:	    if ($error) {
    223:	    *$AUTOLOAD = sub { $val };
    224:	    goto &$AUTOLOAD;
    223:	    *$AUTOLOAD = sub { $val };
   118:	    return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
   119:		unless(defined $laddr);
   121:	    $arg->{PeerAddr} = $arg->{PeerHost}
   122:		if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};
   124:	    unless(exists $arg->{Listen}) {
   125:		($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
   126:						    $arg->{PeerPort},
   127:						    $proto)
   128:				or return _error($sock, $!, $@);
   entering IO::Socket::INET::_sock_info
    36:	  my($addr,$port,$proto) = @_;
    37:	  my $origport = $port;
    38:	  my @proto = ();
    39:	  my @serv = ();
    41:	  $port = $1
    42:		if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
    44:	  if(defined $proto  && $proto =~ /\D/) {
    54:	  if(defined $port) {
    55:	    my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
    56:	    my $pnum = ($port =~ m,^(\d+)$,)[0];
    58:	    @serv = getservbyname($port, $proto[0] || "")
    59:		if ($port =~ m,\D,);
    61:	    $port = $serv[2] || $defport || $pnum;
    62:	    unless (defined $port) {
    67:	    $proto = (getprotobyname($serv[3]))[2] || undef
    68:		if @serv && !$proto;
    71:	 return ($addr || undef,
    72:		 $port || undef,
    73:		 $proto || undef
    74:		);
   131:	    $proto ||= (getprotobyname('tcp'))[2];
   133:	    my $pname = (getprotobynumber($proto))[0];
   134:	    $type = $arg->{Type} || $socket_type{lc $pname};
   136:	    my @raddr = ();
   138:	    if(defined $raddr) {
   139:		@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
   entering IO::Socket::INET::_get_addr
    92:	    my($sock,$addr_str, $multi) = @_;
    93:	    my @addr;
    94:	    if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
    97:		my $h = inet_aton($addr_str);
    entering Socket::inet_aton
    98:		push(@addr, $h) if defined $h;
    100:	    @addr;
   140:		return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
   141:		    unless @raddr;
   144:	    while(1) {
   146:		$sock->socket(AF_INET, $type, $proto) or
   147:		    return _error($sock, $!, "$!");
   entering CODE(0x8537be4)
    223:	    *$AUTOLOAD = sub { $val };
   entering IO::Socket::socket
    77:	    @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
    78:	    my($sock,$domain,$type,$protocol) = @_;
    80:	    socket($sock,$domain,$type,$protocol) or
    81:	    	return undef;
    83:	    ${*$sock}{'io_socket_domain'} = $domain;
    83:	    ${*$sock}{'io_socket_domain'} = $domain;
    84:	    ${*$sock}{'io_socket_type'}   = $type;
    84:	    ${*$sock}{'io_socket_type'}   = $type;
    85:	    ${*$sock}{'io_socket_proto'}  = $protocol;
    85:	    ${*$sock}{'io_socket_proto'}  = $protocol;
    87:	    $sock;
   149:	        if (defined $arg->{Blocking}) {
   154:		if ($arg->{Reuse} || $arg->{ReuseAddr}) {
   159:		if ($arg->{ReusePort}) {
   164:		if ($arg->{Broadcast}) {
   169:		if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
   entering CODE(0x8853300)
    223:	    *$AUTOLOAD = sub { $val };
   174:		if(exists $arg->{Listen}) {
   181:	 	last unless exists($arg->{PeerAddr});
   183:	        $raddr = shift @raddr;
   185:		return _error($sock, $EINVAL, 'Cannot determine remote port')
   186:			unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);
   189:		    unless($type == SOCK_STREAM || defined $raddr);
   entering CODE(0x855404c)
    223:	    *$AUTOLOAD = sub { $val };
   191:		return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
   192:		    unless defined $raddr;
   197:		undef $@;
   198:	        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
   entering Socket::pack_sockaddr_in
   entering IO::Socket::INET::connect
    220:	    @_ == 2 || @_ == 3 or
    221:	       croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
    222:	    my $sock = shift;
    223:	    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
    entering IO::Socket::connect
     106:	    @_ == 2 or croak 'usage: $sock->connect(NAME)';
     107:	    my $sock = shift;
     108:	    my $addr = shift;
     109:	    my $timeout = ${*$sock}{'io_socket_timeout'};
     109:	    my $timeout = ${*$sock}{'io_socket_timeout'};
     110:	    my $err;
     111:	    my $blocking;
     113:	    $blocking = $sock->blocking(0) if $timeout;
     114:	    if (!connect($sock, $addr)) {
     137:	    $sock->blocking(1) if $blocking;
     139:	    $! = $err if $err;
     141:	    $err ? undef : $sock;
   200:	            return $sock;
  2203:		unless ( defined($ret) ) {
  2211:		$self->Socket($sock);
  entering Mail::IMAPClient::Socket
   274:	{   my ($self, $sock) = @_;
   275:	    defined $sock
   276:	        or return $self->{Socket};
   278:	    $self->RawSocket($sock);
   entering Mail::IMAPClient::RawSocket
    260:	{   my ($self, $sock) = @_;
    261:	    defined $sock
    262:	        or return $self->{Socket};
    264:	    $self->{Socket} = $sock;
    265:	    $self->{_select} = IO::Select->new($sock);
    entering IO::Select::new
     24:	 my $self = shift;
     25:	 my $type = ref($self) || $self;
     27:	 my $vec = bless [undef,0], $type;
     29:	 $vec->add(@_)
     30:	    if @_;
     entering IO::Select::add
      37:	 shift->_update('add', @_);
      entering IO::Select::_update
       63:	 my $vec = shift;
       64:	 my $add = shift eq 'add';
       66:	 my $bits = $vec->[VEC_BITS];
       67:	 $bits = '' unless defined $bits;
       69:	 my $count = 0;
       70:	 my $f;
       71:	 foreach $f (@_)
       72:	  {
       73:	   my $fn = $vec->_fileno($f);
       entering IO::Select::_fileno
        55:	 my($self, $f) = @_;
        56:	 return unless defined $f;
        57:	 $f = $f->[0] if ref($f) eq 'ARRAY';
        58:	 ($f =~ /^\d+$/) ? $f : fileno($f);
       74:	   next unless defined $fn;
       75:	   my $i = $fn + FIRST_FD;
       76:	   if ($add) {
       77:	     if (defined $vec->[$i]) {
       81:	     $vec->[FD_COUNT]++;
       82:	     vec($bits, $fn, 1) = 1;
       83:	     $vec->[$i] = $f;
       90:	   $count++;
       92:	 $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
       93:	 $count;
     32:	 $vec;
    267:	    delete $self->{_fcntl};
    268:	    $self->Fast_io($self->Fast_io);
    entering Mail::IMAPClient::Fast_io
     78:	{   my ($self, $use) = @_;
     79:	    defined $use
     80:	       or return $self->{File_io};
    entering Mail::IMAPClient::Fast_io
     78:	{   my ($self, $use) = @_;
     79:	    defined $use
     80:	       or return $self->{File_io};
    270:	    $sock;
   279:	    $self->State(Connected);
   entering CODE(0x83d5ca8)
    64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
   281:	    my $code;
   282:	  LINE:
   283:	    while(my $output = $self->_read_line)
   entering Mail::IMAPClient::_read_line
    1271:	{   my ($self, $literal_callback, $output_callback) = @_;
    1273:	    my $socket = $self->Socket;
    entering Mail::IMAPClient::Socket
     274:	{   my ($self, $sock) = @_;
     275:	    defined $sock
     276:	        or return $self->{Socket};
    1274:	    unless($self->IsConnected && $socket)
    entering Mail::IMAPClient::IsConnected
     2755:	sub IsConnected     { shift->State >= Connected }
     entering CODE(0x83d5ca8)
      64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
    1279:	    my $iBuffer  = "";
    1280:	    my $oBuffer  = [];
    1281:	    my $index    = $self->_next_index;
    entering Mail::IMAPClient::_next_index
     2786:	sub _next_index { my $r = $_[0]->_transaction($_[1]); $r }
     entering Mail::IMAPClient::_transaction
      1455:	sub _transaction(;$) { @{$_[0]->{History}{$_[1] || $_[0]->Transaction} || []} }
      1455:	sub _transaction(;$) { @{$_[0]->{History}{$_[1] || $_[0]->Transaction} || []} }
      entering Mail::IMAPClient::Transaction
       181:	sub Transaction { shift->Count };
       entering CODE(0x83d6194)
        64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
     2786:	sub _next_index { my $r = $_[0]->_transaction($_[1]); $r }
    1282:	    my $timeout  = $self->Timeout;
    entering CODE(0x83d602c)
     64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
    1283:	    my $readlen  = $self->{Buffer} || 4096; 
    1284:	    my $fast_io  = $self->Fast_io;
    entering Mail::IMAPClient::Fast_io
     78:	{   my ($self, $use) = @_;
     79:	    defined $use
     80:	       or return $self->{File_io};
    1286:	    until(@$oBuffer # there's stuff in output buffer:
    1287:	      && $oBuffer->[-1][DATA] =~ /\r\n$/ # the last thing there has cr-lf:
    1288:	      && $oBuffer->[-1][TYPE] eq "OUTPUT" # that thing is an output line:
    1289:	      && !length $iBuffer                 # and the input buffer has been MT'ed:
    1290:	    )
    1291:	    {   my $transno = $self->Transaction;
    entering Mail::IMAPClient::Transaction
     181:	sub Transaction { shift->Count };
     entering CODE(0x83d6194)
      64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
    1293:	        if($timeout)
    1294:	        {   my @ready = $self->{_select}->can_read($timeout);
    entering IO::Select::can_read
     98:	 my $vec = shift;
     99:	 my $timeout = shift;
     100:	 my $r = $vec->[VEC_BITS];
     102:	 defined($r) && (select($r,undef,undef,$timeout) > 0)
     103:	    ? handles($vec, $r)
     104:	    : ();
     entering IO::Select::handles
      215:	 my $vec = shift;
      216:	 my $bits = shift;
      217:	 my @h = ();
      218:	 my $i;
      219:	 my $max = scalar(@$vec) - 1;
      226:	  }
      221:	 for ($i = FIRST_FD; $i <= $max; $i++)
      222:	  {
      223:	   next unless defined $vec->[$i];
      223:	   next unless defined $vec->[$i];
      223:	   next unless defined $vec->[$i];
      223:	   next unless defined $vec->[$i];
      224:	   push(@h, $vec->[$i])
      225:	      if !defined($bits) || vec($bits, $i - FIRST_FD, 1);
      228:	 @h;
    1295:	            unless(@ready)
    1311:	        my $ret = $self->_sysread($socket, \$iBuffer, $readlen,length $iBuffer);
    entering Mail::IMAPClient::_sysread
     1447:	{   my ($self, $fh, $buf, $len, $off) = @_;
     1448:	    my $rm   = $self->Readmethod;
     entering CODE(0x85e5150)
      64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
     1449:	    $rm ? $rm->($self, @_) : sysread($fh, $$buf, $len, $off);
    1312:	        if($timeout && !defined $ret)
    1313:	        {   # Blocking read error...
    1321:	        if(defined $ret && $ret == 0)    # Caught EOF...
    1329:	        while($iBuffer =~ s/^(.*?\r?\n)//)  # consume line
    1330:	        {   my $current_line = $1;
    1338:	            if($current_line !~ s/\s*\{(\d+)\}\r\n$//)
    1339:	            {   push @$oBuffer, [$index++, "OUTPUT" , $current_line];
    1340:	                next;
    1442:	    $self->_debug("Read: ". join "\n      ", map {$_->[DATA]} @$oBuffer);
    1442:	    $self->_debug("Read: ". join "\n      ", map {$_->[DATA]} @$oBuffer);
    entering Mail::IMAPClient::_debug
     45:	{   my $self = shift;
     46:	    return unless $self->Debug;
     entering CODE(0x83d611c)
      64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
     48:	    my $text = join '', @_;
     49:	    $text    =~ s/\r\n/\n  /g;
     50:	    $text    =~ s/\s*$/\n/;
     52:	    my $fh   = $self->{Debug_fh} || \*STDERR;
     53:	    print $fh $text;
    1443:	    @$oBuffer ? $oBuffer : undef;
   284:	    {   foreach my $o (@$output)
   285:	        {   $self->_record($self->Count, $o);
   entering CODE(0x83d6194)
    64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
   entering Mail::IMAPClient::_record
    1160:	{   my ($self, $count, $array) = @_;
    1161:	    if ($array->[DATA] =~ /^\d+ LOGIN/i && !$self->Showcredentials)
    1165:	    push @{$self->{History}{$count}}, $array;
    1165:	    push @{$self->{History}{$count}}, $array;
    1167:	    if($array->[DATA] =~ /^\d+\s+(BAD|NO)\s/im )
    1170:	    $self;
   286:	            next unless $o->[TYPE] eq "OUTPUT";
   288:	            $code = $o->[DATA] =~ /^\*\s+(OK|BAD|NO|PREAUTH)/i ? uc($1) : undef;
   289:	            last LINE;
   292:	    $code or return undef;
   294:	    if($code eq 'BYE' || $code eq 'NO')
   299:	    if($code eq 'PREAUTH')
   304:	    $self->User && $self->Password ? $self->login : $self;
   entering CODE(0x83d5f3c)
    64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  2212:		$self->State(Connected);
  entering CODE(0x83d5ca8)
   64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
  2214:		$sock->autoflush(1)				;
  entering IO::Handle::autoflush
   213:	    my $old = new SelectSaver qualify($_[0], caller);
   entering Symbol::qualify
    39:	    my ($name) = @_;
    40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
    53:	    $name;
   entering SelectSaver::new
    10:	    @_ >= 1 && @_ <= 2 or croak 'usage: new SelectSaver [FILEHANDLE]';
    11:	    my $fh = select;
    12:	    my $self = bless \$fh, $_[0];
    13:	    select qualify($_[1], caller) if @_ > 1;
    entering Symbol::qualify
     39:	    my ($name) = @_;
     40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
     53:	    $name;
    14:	    $self;
   214:	    my $prev = $|;
   215:	    $| = @_ > 1 ? $_[1] : 1;
   216:	    $prev;
   entering SelectSaver::DESTROY
    18:	    my $self = $_[0];
    19:	    select $$self;
  2216:		my ($code, $output);
  2217:	        $output = "";
  2219:	        until ( $code ) {
  2221:	                $output = $self->_read_line or return undef;
  entering Mail::IMAPClient::_read_line
   1271:	{   my ($self, $literal_callback, $output_callback) = @_;
   1273:	    my $socket = $self->Socket;
   entering Mail::IMAPClient::Socket
    274:	{   my ($self, $sock) = @_;
    275:	    defined $sock
    276:	        or return $self->{Socket};
   1274:	    unless($self->IsConnected && $socket)
   entering Mail::IMAPClient::IsConnected
    2755:	sub IsConnected     { shift->State >= Connected }
    entering CODE(0x83d5ca8)
     64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
   1279:	    my $iBuffer  = "";
   1280:	    my $oBuffer  = [];
   1281:	    my $index    = $self->_next_index;
   entering Mail::IMAPClient::_next_index
    2786:	sub _next_index { my $r = $_[0]->_transaction($_[1]); $r }
    entering Mail::IMAPClient::_transaction
     1455:	sub _transaction(;$) { @{$_[0]->{History}{$_[1] || $_[0]->Transaction} || []} }
     1455:	sub _transaction(;$) { @{$_[0]->{History}{$_[1] || $_[0]->Transaction} || []} }
     entering Mail::IMAPClient::Transaction
      181:	sub Transaction { shift->Count };
      entering CODE(0x83d6194)
       64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
    2786:	sub _next_index { my $r = $_[0]->_transaction($_[1]); $r }
   1282:	    my $timeout  = $self->Timeout;
   entering CODE(0x83d602c)
    64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
   1283:	    my $readlen  = $self->{Buffer} || 4096; 
   1284:	    my $fast_io  = $self->Fast_io;
   entering Mail::IMAPClient::Fast_io
    78:	{   my ($self, $use) = @_;
    79:	    defined $use
    80:	       or return $self->{File_io};
   1286:	    until(@$oBuffer # there's stuff in output buffer:
   1287:	      && $oBuffer->[-1][DATA] =~ /\r\n$/ # the last thing there has cr-lf:
   1288:	      && $oBuffer->[-1][TYPE] eq "OUTPUT" # that thing is an output line:
   1289:	      && !length $iBuffer                 # and the input buffer has been MT'ed:
   1290:	    )
   1291:	    {   my $transno = $self->Transaction;
   entering Mail::IMAPClient::Transaction
    181:	sub Transaction { shift->Count };
    entering CODE(0x83d6194)
     64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
   1293:	        if($timeout)
   1294:	        {   my @ready = $self->{_select}->can_read($timeout);
   entering IO::Select::can_read
    98:	 my $vec = shift;
    99:	 my $timeout = shift;
    100:	 my $r = $vec->[VEC_BITS];
    102:	 defined($r) && (select($r,undef,undef,$timeout) > 0)
    103:	    ? handles($vec, $r)
    104:	    : ();
   1295:	            unless(@ready)
   1296:	            {   $self->LastError("Tag $transno: Timeout after $timeout seconds"
   1297:	                    . " waiting for data from server");
   entering Mail::IMAPClient::LastError
    70:	{   my $self = shift;
    71:	    @_ or return $self->{LastError};
    73:	    $self->_debug("ERROR: ", $@ = $self->{LastError} = shift);
    entering Mail::IMAPClient::_debug
     45:	{   my $self = shift;
     46:	    return unless $self->Debug;
     entering CODE(0x83d611c)
      64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
     48:	    my $text = join '', @_;
     49:	    $text    =~ s/\r\n/\n  /g;
     50:	    $text    =~ s/\s*$/\n/;
     52:	    my $fh   = $self->{Debug_fh} || \*STDERR;
     53:	    print $fh $text;
    74:	    $@;
   1299:	                $self->_record($transno,
   1300:	                    [ $self->_next_index($transno), "ERROR"
   1301:	                    , "$transno * NO Timeout after $timeout seconds " .
   1302:	                        "during read from server"]);
   entering Mail::IMAPClient::_next_index
    2786:	sub _next_index { my $r = $_[0]->_transaction($_[1]); $r }
    entering Mail::IMAPClient::_transaction
     1455:	sub _transaction(;$) { @{$_[0]->{History}{$_[1] || $_[0]->Transaction} || []} }
     1455:	sub _transaction(;$) { @{$_[0]->{History}{$_[1] || $_[0]->Transaction} || []} }
     entering Mail::IMAPClient::Transaction
      181:	sub Transaction { shift->Count };
      entering CODE(0x83d6194)
       64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
    2786:	sub _next_index { my $r = $_[0]->_transaction($_[1]); $r }
   entering Mail::IMAPClient::_record
    1160:	{   my ($self, $count, $array) = @_;
    1161:	    if ($array->[DATA] =~ /^\d+ LOGIN/i && !$self->Showcredentials)
    1165:	    push @{$self->{History}{$count}}, $array;
    1165:	    push @{$self->{History}{$count}}, $array;
    1167:	    if($array->[DATA] =~ /^\d+\s+(BAD|NO)\s/im )
    1170:	    $self;
   1304:	                $self->LastError("Timeout after $timeout seconds during "
   1305:	                    . "read from server");
   entering Mail::IMAPClient::LastError
    70:	{   my $self = shift;
    71:	    @_ or return $self->{LastError};
    73:	    $self->_debug("ERROR: ", $@ = $self->{LastError} = shift);
    entering Mail::IMAPClient::_debug
     45:	{   my $self = shift;
     46:	    return unless $self->Debug;
     entering CODE(0x83d611c)
      64:	     *$datum = sub { @_ > 1 ? ($_[0]->{$datum} = $_[1]) : $_[0]->{$datum}
     48:	    my $text = join '', @_;
     49:	    $text    =~ s/\r\n/\n  /g;
     50:	    $text    =~ s/\s*$/\n/;
     52:	    my $fh   = $self->{Debug_fh} || \*STDERR;
     53:	    print $fh $text;
    74:	    $@;
   1307:	                return undef;
 entering IO::Handle::DESTROY
  75:	sub DESTROY {}
 entering IO::Handle::DESTROY
  75:	sub DESTROY {}
entering Config::DESTROY
 62:	sub DESTROY { }
